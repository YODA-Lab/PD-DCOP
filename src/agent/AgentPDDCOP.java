package agent;

import static java.lang.Double.compare;
import static java.lang.System.out;
import static agent.DcopConstants.RANDOM_PREFIX;
import static agent.DcopConstants.DEFAULT_BETA_SAMPLING_SEED;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Serializable;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

import com.google.common.collect.Sets;

import agent.DcopConstants.DcopAlgorithm;
import agent.DcopConstants.DcopType;
import agent.DcopConstants.DynamicType;
import agent.DcopConstants.PDDcopAlgorithm;
import agent.DcopConstants.SwitchingType;

import org.apache.commons.math3.distribution.BetaDistribution;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.random.Well19937c;

import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import behavior.SEND_RECEIVE_FINAL_UTIL;
import behavior.AGENT_TERMINATE;
import behavior.DPOP_UTIL;
import behavior.DPOP_VALUE;
import behavior.INIT_PROPAGATE_DPOP_VALUE;
import behavior.INIT_RECEIVE_DPOP_VALUE;
import behavior.INIT_RECEIVE_SEND_LS_UTIL;
import behavior.LS_RECEIVE_SEND_LS_UTIL;
import behavior.MESSAGE_TYPE;
import behavior.MGM_RAND_PICK_VALUE;
import behavior.MGM_SEND_RECEIVE_IMPROVE;
import behavior.MGM_SEND_RECEIVE_UTIL;
import behavior.MGM_SEND_RECEIVE_VALUE;
import behavior.PSEUDOTREE_GENERATION;
import behavior.LS_RAND_PICK_VALUE;
import behavior.LS_RECEIVE_IMPROVE;
import behavior.SEND_RECEIVE_FINAL_VALUE;
import function.Interval;
import function.multivariate.MultivariateQuadFunction;
import function.multivariate.PiecewiseMultivariateQuadFunction;
import behavior.R_LEARNING_UPDATE;
import behavior.LS_RECEIVE_VALUE;
import behavior.SEARCH_NEIGHBORS;
import behavior.LS_SEND_IMPROVE;
import table.AugmentedState;
import table.Row;
import table.Table;
import transition.TransitionFamilyDistribution;
import transition.TransitionFunction;
import jade.core.AID;
import jade.core.Agent;
import jade.core.behaviours.SequentialBehaviour;
import jade.domain.DFService;
import jade.domain.FIPAException;
import jade.domain.FIPAAgentManagement.DFAgentDescription;
import jade.domain.FIPAAgentManagement.ServiceDescription;
import jade.lang.acl.ACLMessage;

/* Each agent is a node in the graph
 * The graph is presented as pseudo-tree
 * Pseudo-tree is generated by Distributed DFS
 * 
 * Each Agent has a "root" flag to indicate root or not
 * Each Agent has a local name which is an ID number and is assigned by constructor.
 * Based on the ID number, each agent has a fixed number neighbors, which is instantiated
 * by the constructor
 * 
 * ****PROCESS OF FINDING AID NEIGHBORS
 * Each Agent has a list of neighbors, and register his neighbors ID number to DF
 * Each Agent find his neighbors' AIDs by searching DF which agents register the Agent's ID numbers as
 * a neighbor. The add to his list of AID neighbors.
 * 
 * The process of finding AIDs only stops when the number of recognized AID is the number of his neighbors
 * 
 * ****PROCESS OF GENERATING PSEUDOTREE
 * Each agent always listens to the first messages, while trying to finish the searching process
 * After finishing the searching process, he begins to process the messages and send the message to his
 * neighbors.
 * 
 * Agent root start sending messages when finish searching agents.
 * 
 * Each agents will print out his parent, his children, his pseudo-parents, his pseudo-children
 * 
 * ****PROCESS OF DPOP
 * DPOP starts when the PSEUDOTREE PROCESS FINISHED
 */
/**
 * @author khoihd
 *
 */
public class AgentPDDCOP extends Agent {

	private static final long serialVersionUID = 2919994686894853596L;

	public static final String INPUT_FOLDER = "input_files";

	public static final SwitchingType SWITCHING_TYPE = SwitchingType.CONSTANT;
	public static final int MAX_ITERATION = 40;
	public static final int MARKOV_CONVERGENCE_TIME_STEP = 40;
	public static final boolean RANDOM_TABLE = true;
	public static final boolean DECISION_TABLE = false;
	public static final boolean NOT_TO_OPTIMIZE_INTERVAL = false;
	public static final boolean TO_OPTIMIZE_INTERVAL = true;

	/*
	 * DCOP parameters To be read from arguments
	 */
	private String agentID;
	private PDDcopAlgorithm pddcop_algorithm;
	private DcopAlgorithm dcop_algorithm;
	private DcopType dcopType;
	private int horizon;
	private double switchingCost;
	private DynamicType dynamicType;
	private double discountFactor;
	private String inputFileName;
	private double heuristicWeight;
	
	private static Interval globalInterval;
	// mapping <neighbor, function<>
	private Map<String, PiecewiseMultivariateQuadFunction> functionMap = new HashMap<>();
	// for Hybrid Max-Sum
		private Map<String, PiecewiseMultivariateQuadFunction> MSFunctionMapIOwn = new HashMap<>();
//	private int onlineRun;
	/*
	 * Read from input file
	 */
	private int instanceID;
	/*
	 * Computed from the arguments
	 */
	private String outputFileName;
	private String localSearchOutputFileName;
	private String onlineOutputFileName;
	private int hybridTS;

	private boolean isRoot = false;
	private boolean isLeaf = false;

	private AID parentAID;
	private Set<AID> childrenAIDSet = new HashSet<>();
	private Set<AID> neighborAIDSet = new HashSet<>();
	private Set<AID> pseudoParentAIDSet = new HashSet<>();
	private Set<AID> pseudoChildrenAIDSet = new HashSet<>();
	private List<String> parentAndPseudoStrList = new ArrayList<>();
	private Set<String> neighborStrSet = new HashSet<>();

	private List<Table> dpopDecisionTableList = new ArrayList<>();
	private List<Table> dpopRandomTableList = new ArrayList<>();
	@SuppressWarnings("unused")
	private List<Table> dpopBoundRandomTableList = new ArrayList<>();
	private SortedMap<String, List<String>> boundDpopRandomDomains = new TreeMap<>();

	private List<Table> mgmTableList = new ArrayList<>();

	private List<Table> rawDecisionTableList = new ArrayList<>();
	private List<Table> rawRandomTableList = new ArrayList<>();

	private List<String> decisionVariableList = new ArrayList<>();
//	private List<String> selfVariableList = new ArrayList<>();
	private HashMap<String, List<String>> decisionVariableDomainMap = new HashMap<>();
	private HashMap<String, Interval> decisionVariableIntervalMap = new HashMap<>();
	private HashMap<String, List<String>> selfRandomVariableDomainMap = new HashMap<>();
	private HashMap<String, Interval> selfRandomVariableIntervalMap = new HashMap<>();
	// map TS -> constraint table list (if local_search)
	// map TS -> 1 collapsed table list (if collapsed dpop)
	private HashMap<Integer, List<Table>> discountedExpectedTableEachTSMap = new HashMap<>();
	private HashMap<String, double[][]> probabilityAtEachTimeStepMap = new HashMap<>();

	// VALUE phase
	private Map<String, String> valuesToSendInVALUEPhase = new HashMap<>();

	// used for LOCAL SEARCH
	private Map<Integer, String> chosenValueAtEachTSMap = new HashMap<>();
	// List<Double> utilityAtEachTSList;
	// agent -> <values0, values1, ..., values_n>
	private Map<String, HashMap<Integer, String>> agentViewEachTimeStepMap = new HashMap<>();
	private List<Double> currentGlobalUtilityList = new ArrayList<>();
	private Map<Integer, String> bestImproveValueMap = new HashMap<>();
	private Map<Integer, Double> bestImproveUtilityMap = new HashMap<>();

	/**
	 * Object since it could be null
	 */
//	private double currentLocalSearchSolutionQuality;
	private double solutionQuality;
	private Map<Integer, Double> effectiveQualityMap = new HashMap<>();
	private Map<Integer, Double> effectiveSwitchingCostMap = new HashMap<>();
	private Map<Integer, Long> effectiveSolvingTimeMap = new HashMap<>();

//	private Map<String, List<Double>> initProabilityMap = new HashMap<>();
	/**
	 * Random variable -> TransitionFunction
	 */
	private Map<String, TransitionFunction> transitionFunctionMap = new HashMap<>();
	private Table agentViewTable;
	private Map<Integer, String> pickedRandomMap = new HashMap<>();

	private long currentUTILstartTime;

	// simulated time
	private ThreadMXBean bean;
	private long simulatedTime = 0;
	private long currentStartTime;
	private static long delayMessageTime = 0; // in milliseconds

	// for reuse information
	private Map<String, Double> agentHeuristicStringMap = new HashMap<>();
	private boolean notVisited = true;

	// List<String> neighborWithRandList;

	// Mapping from iteration to quality/runtime. Store the quality of the best LS
	// solution.
	private Map<Integer, Double> localSearchQualityMap = new HashMap<>();
	private Map<Integer, Long> localSearchRuntimeMap = new HashMap<>();

	private Map<Integer, Double> MGMQualityMap = new HashMap<>();
	private Map<Integer, Long> MGMRuntimeMap = new HashMap<>();

//	private double lastMGMQuality = 0D;
//	private long lastMGMRuntime = 0L;

	// Mapping from horizon to the difference in runtime of when the solution
	// converges to the last time step
	private Map<Integer, Long> MGMdifferenceRuntimeMap = new HashMap<>();
	
	// R_Learning
//	private Map<Integer, String> randomRealizationForLearning = new HashMap<>();

	private Map<AugmentedState, Double> RFunction = new HashMap<>();

	private double averageRewardR = 0;
	private boolean isSolvingForCurrentState = true;
	private String solutionForCurrentState;
	private String solutionForNextState;
	private double alpha_r = 0.05;
	private double beta_r = 0.5;
	private int rLearningIteration;
	private boolean isApplyingRLearning = true;
	

	private boolean stop = false;
	private String lastLine = "";
	private int agentCount;
	private int randomCount;
	// Root is the agent with most neighbors
	private String rootAgent;

	private boolean recomputingDPOP_UTIL = true; // default, all agents have to recompute everything
	private Table storedReuseTable;
	private Set<String> reuseChildUTIL = new HashSet<>();
	private Random rdn = new Random();
	private Map<Integer, List<Table>> actualDpopTableAcrossTimeStep = new HashMap<>();
	private Map<Integer, List<Table>> actualTableAcrossTimeStep = new HashMap<>();

	private Map<Integer, Long> onlineSolvingTime = new HashMap<>();
	private long finalRuntime;

	private String CDPOP_value;
	private long randomSeed;

	public int decisionDomain;
	public int randomDomain;
	
	private BetaDistribution initialDistribution = new BetaDistribution(0, 0);
	private TransitionFamilyDistribution transitionDistribution = TransitionFamilyDistribution.of();

	public static String OUTPUT_FOLDER;

	public AgentPDDCOP() {
	}

	private void setOutputFileName() {
		StringBuffer sb = new StringBuffer();
		OUTPUT_FOLDER = "output_files/" + dynamicType + "/";
		try {
			Files.createDirectories(Paths.get(OUTPUT_FOLDER));
		} catch (IOException e) {
			e.printStackTrace();
		}

		sb.append("x=" + agentCount);
		sb.append("_y=" + randomCount);
		sb.append("_dx=" + decisionDomain);
		sb.append("_dy=" + randomDomain);
		sb.append("_sw=" + (int) switchingCost);
		sb.append("_h=" + horizon);
		sb.append("_discountFactor=" + discountFactor);
		sb.append("_heuristicWeight=" + heuristicWeight);
		sb.append("_" + pddcop_algorithm + "_" + dcop_algorithm + "_" + dynamicType);
		if (pddcop_algorithm == PDDcopAlgorithm.R_LEARNING) {
			sb.append("_rLearningIteration=" + rLearningIteration);
			sb.append("_alpha=" + alpha_r);
			sb.append("_beta=" + beta_r);
		}
		sb.append(".txt");

		outputFileName = OUTPUT_FOLDER + sb.toString();
		if (isRunningPDDCOPLocalSearch() || dynamicType == DynamicType.ONLINE || dynamicType == DynamicType.STATIONARY) {
			String localSearchFolder = OUTPUT_FOLDER + "/" + pddcop_algorithm + "_" + dcop_algorithm + "/";
			try {
				Files.createDirectories(Paths.get(localSearchFolder));
			} catch (IOException e) {
				e.printStackTrace();
			}

			sb.insert(0, "instanceID=" + instanceID + "_");
			localSearchOutputFileName = localSearchFolder + sb.toString();
//			onlineOutputFileName = localSearchFolder + "OnlineRun=" + onlineRun + "_" + sb.toString();
			onlineOutputFileName = localSearchOutputFileName; 
		}
	}

	public void readArguments() {
		Object[] args = getArguments();
		out.println(Arrays.deepToString(args));

		// parameters for running experiments
		pddcop_algorithm = PDDcopAlgorithm.valueOf((String) args[0]);
		dcop_algorithm = DcopAlgorithm.valueOf((String) args[1]);
		inputFileName = (String) args[2]; // random_x14_y123/instance_10_x14_y123.dzn
		horizon = Integer.valueOf((String) args[3]);
		switchingCost = Integer.valueOf((String) args[4]);
		discountFactor = Double.valueOf((String) args[5]);
		dynamicType = DynamicType.valueOf((String) args[6]);
		heuristicWeight = Double.valueOf((String) args[7]);
		rLearningIteration = Integer.valueOf((String) args[8]);
		dcopType = DcopType.valueOf((String) args[9]);
//		setOnlineRun(Integer.valueOf((String) args[8]));

		String a[] = inputFileName.substring(inputFileName.indexOf("/") + 1).replaceAll("instance_", "")
				.replaceAll(".dzn", "").split("_");

		instanceID = Integer.valueOf(a[0]);

		agentCount = Integer.valueOf(a[1].replace("x", ""));
		randomCount = Integer.valueOf(a[2].replace("y", ""));
		decisionDomain = Integer.valueOf(a[3].replace("dx", ""));
		randomDomain = Integer.valueOf(a[4].replace("dy", ""));

		agentID = getLocalName();

		for (int timeStep = 0; timeStep <= horizon; timeStep++) {
			discountedExpectedTableEachTSMap.put(timeStep, new ArrayList<Table>());
		}

		// Different seed values for combination of (instanceID, agentID)
		randomSeed = (instanceID + 1) * Integer.valueOf(agentID) * horizon;
//		randomSeed = (instanceID + 1) * Integer.valueOf(agentID) * horizon * (onlineRun + 1);
		rdn.setSeed(randomSeed);
	}

	public int getrLearningIteration() {
		return rLearningIteration;
	}

	public void setrLearningIteration(int rLearningIteration) {
		this.rLearningIteration = rLearningIteration;
	}

	protected void setup() {
		readArguments();
		
		if (dcopType == DcopType.DISCRETE) {
			parseInputFileDiscrete(INPUT_FOLDER + "/" + inputFileName);
		} else {
			parseInputFileContinuous(INPUT_FOLDER + "/" + inputFileName);
		}

		// Set root
		isRoot = agentID.equals(rootAgent);
		
		setOutputFileName();

		if (isRoot) {
			print("AgentID = " + agentID);
			print("PDDCOP Algorithm = " + pddcop_algorithm);
			print("DCOP Algorithm = " + dcop_algorithm);
			print("Input file name = " + inputFileName);
			print("InstanceID = " + instanceID);
			print("Switching cost = " + switchingCost);
			print("Discount factor = " + discountFactor);
			print("Horizon = " + horizon);
			print("Heuristic weight = " + heuristicWeight);
			print("Max iteration=" + MAX_ITERATION);
		}

		registerWithDF();
		bean = ManagementFactory.getThreadMXBean();
		bean.setThreadContentionMonitoringEnabled(true);

		int theLastTimeStep = simulateActualValueAndComputeDistribution();
		
		// Simulate random variables for R_LEARNING
		if (pddcop_algorithm == PDDcopAlgorithm.R_LEARNING) {
			simulateActualValueForRLearning();
			
			// Initialize R functions
			for (String previous : decisionVariableDomainMap.get(agentID)) {
				for (String current : decisionVariableDomainMap.get(agentID)) {
					for (String random : selfRandomVariableDomainMap.get(agentID)) {
						AugmentedState state = AugmentedState.of(random, previous, current);
						RFunction.put(state, 0D);
						
						// Previous = null for the case of horizon = 0
						AugmentedState state_null_prev = AugmentedState.of(random, current);
						RFunction.put(state_null_prev, 0D);
					}
				}	
			}
		}

		print("pickedRandomMap=" + pickedRandomMap);
		print("probabilityAtEachTimeStepMap=");
		for (Entry<String, double[][]> entry : probabilityAtEachTimeStepMap.entrySet()) {
			print(entry.getKey() + "=" + Arrays.deepToString(entry.getValue()));
		}

		SequentialBehaviour mainSequentialBehaviourList = new SequentialBehaviour();
		// Done reviewing these two behaviors
		mainSequentialBehaviourList.addSubBehaviour(new SEARCH_NEIGHBORS(this));
		mainSequentialBehaviourList.addSubBehaviour(new PSEUDOTREE_GENERATION(this));

		// TODO:
		if (pddcop_algorithm == PDDcopAlgorithm.BOUND_DPOP) {
			SortedSet<SortedMap<String, String>> boundDpopRandomCombinations = computeRandomCombinations(
					boundDpopRandomDomains);

			for (SortedMap<String, String> randomValueMapping : boundDpopRandomCombinations) {
				// Modify the constraint tables with random variables
//		    dpopRandomTableList

				dpopBoundRandomTableList = computeDpopBoundRandomTable(dpopRandomTableList, randomValueMapping);

				// TODO: solve with max
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, horizon));
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, horizon));

				// TODO: solve with min

				// Store the max/min utility value

				// Root agent will write down the maximum difference in (max - min) value to the
				// output file

				// Naming the output file and writing down the value
			}

		}

		// Solve for the last time step for INFINITE
		if (dynamicType == DynamicType.INFINITE_HORIZON) {
			if (dcop_algorithm == DcopAlgorithm.DPOP && pddcop_algorithm != PDDcopAlgorithm.LS_RAND) {
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, horizon));
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, horizon));
			} else if (dcop_algorithm == DcopAlgorithm.MGM) {
				mainSequentialBehaviourList.addSubBehaviour(new MGM_RAND_PICK_VALUE(this, horizon));
				for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
					mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_VALUE(this, horizon));
					mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_IMPROVE(this, horizon));
					mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_UTIL(this, horizon, localTS));
				}
			}
		}

		// Combine DCOPs from 0 -> theLastTimeStep
		// Take into account the switching cost to the solution at horizon h if there is any
		if (pddcop_algorithm == PDDcopAlgorithm.C_DCOP) {
			if (dcop_algorithm == DcopAlgorithm.DPOP) {
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, theLastTimeStep));
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, theLastTimeStep));
			}
		} else if (isAlgorithmIn(new PDDcopAlgorithm[] { PDDcopAlgorithm.LS_SDPOP, PDDcopAlgorithm.FORWARD,
				PDDcopAlgorithm.HYBRID, PDDcopAlgorithm.REACT })) {
			for (int i = 0; i <= theLastTimeStep; i++) {
				if (dcop_algorithm == DcopAlgorithm.DPOP) {
					mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
					mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));
				} else if (dcop_algorithm == DcopAlgorithm.MGM) {
					mainSequentialBehaviourList.addSubBehaviour(new MGM_RAND_PICK_VALUE(this, i));
					for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
						mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_VALUE(this, i));
						mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_IMPROVE(this, i));
						mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_UTIL(this, i, localTS));
					}
				}
			}
		} else if (pddcop_algorithm == PDDcopAlgorithm.BACKWARD) {
			for (int i = theLastTimeStep; i >= 0; i--) {
				if (dcop_algorithm == DcopAlgorithm.DPOP) {
					mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
					mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));
				} else if (dcop_algorithm == DcopAlgorithm.MGM) {
					mainSequentialBehaviourList.addSubBehaviour(new MGM_RAND_PICK_VALUE(this, i));
					for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
						mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_VALUE(this, i));
						mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_IMPROVE(this, i));
						mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_UTIL(this, i, localTS));
					}
				}
			}
		} else if (pddcop_algorithm == PDDcopAlgorithm.LS_RAND) {
			mainSequentialBehaviourList.addSubBehaviour(new LS_RAND_PICK_VALUE(this));
		} else if (pddcop_algorithm == PDDcopAlgorithm.R_LEARNING) {
			// Behaviors for learning the R function
			// Solving DCOP with current state ~ similar to REACT
			// Solving DCOP with the next state ~ similar to REACT
			// Behaviors for running the online version
			for (int i = 0; i <= rLearningIteration - 1; i++) {
				// Solving for current state
				isSolvingForCurrentState = true;
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));				
				// Update R and average reward only when having the solution of the previous state and the current state
				if (i > 0) {
					mainSequentialBehaviourList.addSubBehaviour(new R_LEARNING_UPDATE(this, i-1));
				}
			}
			
			// Mapping R-learning to DCOPs and solve for solution
			for (int i = 0; i <= theLastTimeStep; i++) {
				// R-learning values are converted into utility function in DPOP_UTIL
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));
			}
		}

		// Add the discounted tables to time steps 0 -> lastTimeStep for all algorithms
		// In order to compute solution quality of PD-DCOP
		// Not used for solving PD-DCOPs
		for (int timeIndex = 0; timeIndex <= horizon; timeIndex++) {
			discountedExpectedTableEachTSMap.get(timeIndex)
					.addAll(computeDiscountedDecisionTableList(rawDecisionTableList, timeIndex, discountFactor));
			discountedExpectedTableEachTSMap.get(timeIndex)
					.addAll(computeDiscountedExpectedRandomTableList(rawRandomTableList, timeIndex, discountFactor));
		}

		// Behaviors for local search approaches of PD-DCOPs
		if (isAlgorithmIn(new PDDcopAlgorithm[] { PDDcopAlgorithm.LS_RAND, PDDcopAlgorithm.LS_SDPOP })) {
			mainSequentialBehaviourList.addSubBehaviour(new INIT_PROPAGATE_DPOP_VALUE(this));
			mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_DPOP_VALUE(this));
			mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_SEND_LS_UTIL(this));

			for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
				mainSequentialBehaviourList.addSubBehaviour(new LS_SEND_IMPROVE(this, theLastTimeStep, localTS));
				mainSequentialBehaviourList.addSubBehaviour(new LS_RECEIVE_IMPROVE(this, theLastTimeStep, localTS));
				mainSequentialBehaviourList.addSubBehaviour(new LS_RECEIVE_VALUE(this, theLastTimeStep, localTS));
				mainSequentialBehaviourList
						.addSubBehaviour(new LS_RECEIVE_SEND_LS_UTIL(this, theLastTimeStep, localTS));
			}
		}

		mainSequentialBehaviourList.addSubBehaviour(new SEND_RECEIVE_FINAL_VALUE(this));
		mainSequentialBehaviourList.addSubBehaviour(new SEND_RECEIVE_FINAL_UTIL(this));

		mainSequentialBehaviourList.addSubBehaviour(new AGENT_TERMINATE(this));
		addBehaviour(mainSequentialBehaviourList);
	}

	private List<Table> computeDpopBoundRandomTable(List<Table> randTableList, SortedMap<String, String> mapping) {
		List<Table> resultingList = new ArrayList<>();

		for (Table randTable : randTableList) {
			String randVariable = randTable.getRandVarLabel().get(0);
			String randValue = mapping.get(randVariable);

			Table table = new Table(randTable.getDecVarLabel(), false);
			for (Row row : table.getRowList()) {
				if (row.getRandomList().contains(randValue)) {
					table.addRow(new Row(row.getValueList(), row.getUtility()));
				}
			}

			resultingList.add(table);
		}

		return resultingList;
	}

	// Given a mapping: random variable -> List of values (domain)
	// Compute a set that contains mapping: random variable -> value
	private SortedSet<SortedMap<String, String>> computeRandomCombinations(
			SortedMap<String, List<String>> randomVariableDomains) {
		SortedSet<SortedMap<String, String>> realizationCombinations = new TreeSet<>();

		SortedSet<String> randomVariableSortedSet = new TreeSet<>();
		randomVariableSortedSet.addAll(randomVariableDomains.keySet());

		// Convert randomVariableDomains into the array list that contains the sorted
		// set of values
		// In order to call Set.cartesianProduct
		List<SortedSet<String>> domainForCatesianProduct = new ArrayList<>();
		for (Entry<String, List<String>> entry : randomVariableDomains.entrySet()) {
			SortedSet<String> set = new TreeSet<>();
			set.addAll(entry.getValue());
			domainForCatesianProduct.add(set);
		}

		Set<List<String>> realizationSet = Sets.cartesianProduct(domainForCatesianProduct);

		for (List<String> entry : realizationSet) {
			int index = 0;

			SortedMap<String, String> realization = new TreeMap<>();
			for (String random : randomVariableSortedSet) {
				realization.put(random, entry.get(index));
				index++;
			}

			realizationCombinations.add(realization);
		}

		return realizationCombinations;
	}
	
	private void simulateActualValueForRLearning() {		
		// From there, simulate the value of random variables
		// The initial distribution has been assigned using the stationary distribution
		for (int indexTime = 0; indexTime <= rLearningIteration; indexTime++) {
			// Only simulate states for time step that was not used for simulation before
			if (!pickedRandomMap.containsKey(indexTime)) {
				// Since R_LEARNING is STATIONARY, the initial distribution is also the stationary distribution
				pickedRandomMap.put(indexTime, simulateOnlineValue(indexTime));	
			}
		}
	}

	/**
	 * REVIEWED <br>
	 * Simulate values for self random variable <br>
	 * Then compute distribution at every time step depending on the dynamic type
	 * <br>
	 * Return lastTimeStep=horizon if FINITE/ONLINE OR return lastTimeStep=horizon -
	 * 1 if INFINITE
	 * 
	 * @return
	 */
	private int simulateActualValueAndComputeDistribution() {
		int lastTimeStep = 0;

		if (dynamicType == DynamicType.FINITE_HORIZON || dynamicType == DynamicType.ONLINE || dynamicType == DynamicType.STATIONARY) {
			lastTimeStep = horizon;
		} else if (dynamicType == DynamicType.INFINITE_HORIZON) {
			lastTimeStep = horizon - 1;
		}

		if (!selfRandomVariableDomainMap.containsKey(agentID)) {
			return lastTimeStep;
		}

		int randomDomainSize = selfRandomVariableDomainMap.get(agentID).size();
		
		// Simulate for ONLINE
		if (dynamicType == DynamicType.ONLINE) {
			for (int indexTime = 0; indexTime <= horizon; indexTime++) {
				pickedRandomMap.put(indexTime, simulateOnlineValue(indexTime));
				
				if (pddcop_algorithm == PDDcopAlgorithm.HYBRID) {
					createProbabilityWithObservation(indexTime + 1);
				} else if (pddcop_algorithm == PDDcopAlgorithm.FORWARD && indexTime > 0) {
					probabilityAtEachTimeStepMap.get(agentID)[indexTime] = new double[randomDomainSize];
					computeExpectedProbabilityAtTimeStep(indexTime);
				}
			}
		}
		// Simulate for STATIONARY
		else if (dynamicType == DynamicType.STATIONARY) {
			// Initial distribution = Converged distribution
			computeStationaryDistributionAsInitial();
			
			// Simulate actual value of random variables
			for (int indexTime = 0; indexTime <= horizon; indexTime++) {
				pickedRandomMap.put(indexTime, simulateOnlineValue(indexTime));
				
				// Set the probability distribution of FORWARD STATIONARY to the INITIAL PROBABILITY DISTRIBUTION
				// Used for solving each DCOP with the same stationary distribution
				if (pddcop_algorithm == PDDcopAlgorithm.FORWARD) {
					probabilityAtEachTimeStepMap.get(agentID)[indexTime] = probabilityAtEachTimeStepMap.get(agentID)[0];
				}
			}
		}
		// Compute distributions for other dynamics
		// Compute up to horizon - 1 for INFINITE and horizon for FINITE
		else {
			// timeIndex = 0 is the initial probability distribution
			for (int timeIndex = 1; timeIndex <= lastTimeStep; timeIndex++) {
				probabilityAtEachTimeStepMap.get(agentID)[timeIndex] = new double[randomDomainSize];
				computeExpectedProbabilityAtTimeStep(timeIndex);
			}
		}

		if (dynamicType == DynamicType.INFINITE_HORIZON) {
			computeExpectedProbabilityAtTimeStep(AgentPDDCOP.MARKOV_CONVERGENCE_TIME_STEP);
		}

		return lastTimeStep;
	}

	// JADE function: stop the Agent
	protected void takeDown() {
//		print("Agent " + agentID + " with threadID " + Thread.currentThread().getId()
//				+ " has SIMULATED TIME: " + simulatedTime / 1000000 + "ms");
		print("terminated");
		try {
			DFService.deregister(this);
		} catch (FIPAException e) {
			e.printStackTrace();
		}
	}

	/**
	 * REVIEWED
	 * 
	 * @param lastTimeStep
	 */
	public void sendImprove(int lastTimeStep) {
		startSimulatedTiming();

		List<Double> currentUtilityList = utilityLSMinusCostOverTS(chosenValueAtEachTSMap, lastTimeStep);

		List<Set<String>> domainAcrossTimeSteps = new ArrayList<Set<String>>();

		for (int ts = 0; ts <= lastTimeStep; ts++) {
			Set<String> linkedValueSet = new LinkedHashSet<>();
			for (String value : getSelfDomain()) {
				linkedValueSet.add(value);
			}
			domainAcrossTimeSteps.add(linkedValueSet);
		}

		Set<List<String>> cartesianProduct = Sets.cartesianProduct(domainAcrossTimeSteps);

		double maxUtility = -Double.MAX_VALUE;
		Map<Integer, String> bestValueMapTS = new HashMap<>();

		for (List<String> valueListTS : cartesianProduct) {
			double evaluation = cumulativeUtilityLSMinusCost(valueListTS);
			if (Double.compare(evaluation, maxUtility) > 0) {
				maxUtility = evaluation;
				for (int i = 0; i < valueListTS.size(); i++) {
					bestValueMapTS.put(i, valueListTS.get(i));
				}
			}
		}

		if (Double.compare(maxUtility, -Double.MAX_VALUE) > 0) {
			bestImproveValueMap.putAll(bestValueMapTS);
			List<Double> bestUtilityList = utilityLSMinusCostOverTS(bestImproveValueMap, lastTimeStep);
			for (int i = 0; i <= lastTimeStep; i++) {
				bestImproveUtilityMap.put(i, bestUtilityList.get(i) - currentUtilityList.get(i));
			}
		} else {
			bestImproveValueMap.clear();
		}

		stopStimulatedTiming();

		for (AID neighbor : neighborAIDSet) {
			sendObjectMessageWithTime(neighbor, bestImproveUtilityMap, MESSAGE_TYPE.LS_IMPROVE, simulatedTime);
		}
	}

	/**
	 * REVIEWED <br>
	 * Remove children and pseudoChildren constraint table
	 */
	public List<Table> getTableWithoutChildrenAndPseudochilren(List<Table> tableList) {
		Set<String> childAndPseudoChildrenStrSet = new HashSet<String>();

		for (AID childrenAID : childrenAIDSet) {
			childAndPseudoChildrenStrSet.add(childrenAID.getLocalName());
		}
		for (AID pseudoChildrenAID : pseudoChildrenAIDSet) {
			childAndPseudoChildrenStrSet.add(pseudoChildrenAID.getLocalName());
		}

		List<Table> resultingTableList = new ArrayList<>();

		for (Table constraintTable : tableList) {
			List<String> intersectList = new ArrayList<>(constraintTable.getDecVarLabel());

			intersectList.remove(agentID);
			intersectList.retainAll(childAndPseudoChildrenStrSet);

			if (intersectList.isEmpty()) {
				resultingTableList.add(constraintTable);
			}
		}

		return resultingTableList;
	}

	/**
	 * REVIEWED
	 * 
	 * @param valuesOverTS
	 * @return
	 */
	private double cumulativeUtilityLSMinusCost(List<String> valuesOverTS) {
		double sumUtility = 0;
		double sumCost = 0;

		for (int ts = 0; ts < valuesOverTS.size(); ts++) {
			List<Table> tableList = discountedExpectedTableEachTSMap.get(ts);

			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVarList) {
					if (neighbor.equals(agentID))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}

		for (int i = 0; i < valuesOverTS.size() - 1; i++) {
			sumCost += Math.pow(discountFactor, i)
					* switchingCostFunction(valuesOverTS.get(i), valuesOverTS.get(i + 1));
		}
		return sumUtility - sumCost;
	}

	/**
	 * REVIEWED <br>
	 * Compute current local quality at each time step in MGM
	 * 
	 * @param timeStepValueMap
	 * @param timeStep
	 * @return
	 */
	private List<Double> utilityLSMinusCostOverTS(Map<Integer, String> timeStepValueMap, int timeStep) {
		List<Double> utilityList = new ArrayList<>();

		for (int ts = 0; ts <= timeStep; ts++) {
			double switchingCost = 0;
			double utility = 0;

			if (ts == 0) {
				switchingCost = Math.pow(discountFactor, 0)
						* switchingCostFunction(timeStepValueMap.get(0), timeStepValueMap.get(1));
			}
			// Switching cost function returns 0 if the second argument is null
			else {
				switchingCost = Math.pow(discountFactor, ts - 1)
						* switchingCostFunction(timeStepValueMap.get(ts - 1), timeStepValueMap.get(ts))
						+ Math.pow(discountFactor, ts)
								* switchingCostFunction(timeStepValueMap.get(ts), timeStepValueMap.get(ts + 1));
			}
			// from each utility constraint with neighbors at a timeStep
			// get names -> get values from agent_view
			// from neighbors' values, current value -> get utility from
			// constraint table
			List<Table> tableList = discountedExpectedTableEachTSMap.get(ts);
			// System.err.println("Agent " + idStr + " size " +
			// tableList.size());

			for (Table constraintTable : tableList) {
				List<String> decVariableList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVariableList) {
					if (neighbor.equals(agentID)) {
						decValueList.add(timeStepValueMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
					}
				}

				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}

			utilityList.add(utility - switchingCost);
		}

		return utilityList;
	}

	// utilityMinusCostOverTSList
	List<Double> utilityMinusCostOverTSList(List<String> valuesOverTS) {
		List<Double> utilityList = new ArrayList<Double>();
		for (int ts = 0; ts <= horizon; ts++) {
			double sc = 0;
			double utility = 0;
			if (ts == 0)
				// sc = (valuesOverTS.get(0).equals(valuesOverTS.get(1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(0), valuesOverTS.get(1));
			else if (ts == horizon)
				// sc = (valuesOverTS.get(h).equals(valuesOverTS.get(h-1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(horizon), valuesOverTS.get(horizon - 1));
			else
				// sc = (valuesOverTS.get(ts-1).equals(valuesOverTS.get(ts))
				// ? 0 : switchingCost)
				// + (valuesOverTS.get(ts).equals(valuesOverTS.get(ts+1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(ts - 1), valuesOverTS.get(ts))
						+ switchingCostFunction(valuesOverTS.get(ts), valuesOverTS.get(ts + 1));

			// from each utility constraint with neighbors at a timeStep
			// get names -> get values from agent_view
			// from neighbors' values, current value -> get utility from
			// constraint table
			List<Table> tableList = discountedExpectedTableEachTSMap.get(ts);
			// System.err.println("Agent " + idStr + " size " +
			// tableList.size());
			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVarList) {
					if (neighbor.equals(agentID))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
				}
				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}

			utilityList.add(utility - sc);
		}
		return utilityList;
	}

	/**
	 * Assign the distribution for this time step given the observed value from the
	 * previous one
	 * 
	 * @param timeStep
	 */
	public void createProbabilityWithObservation(int timeStep) {
		if (timeStep == 0 || timeStep > horizon) {
			return;
		}

		String randVariable = agentID;

		double distribution[] = toArray(
				transitionFunctionMap.get(randVariable).getTransitionOf(pickedRandomMap.get(timeStep - 1)));
		probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = distribution;
	}

	/**
	 * Compute probability distribution at each time step <br>
	 * If timeStep = MARKOV_CONVERGENCE_TIME_STEP, compute the stationary
	 * distribution at horizon
	 * 
	 * @param timeStep
	 */
	public void computeExpectedProbabilityAtTimeStep(int timeStep) {
		for (String randVariable : selfRandomVariableDomainMap.keySet()) {
			if (timeStep == MARKOV_CONVERGENCE_TIME_STEP) {
				double[] probability = probabilityAtEachTimeStepMap.get(randVariable)[horizon - 1];
				for (int h = horizon - 1; h <= MARKOV_CONVERGENCE_TIME_STEP; h++) {
					probability = multiply(probability, transitionFunctionMap.get(randVariable));
				}
				probabilityAtEachTimeStepMap.get(randVariable)[horizon] = probability;
			} else {
				double[] prevDistribution = probabilityAtEachTimeStepMap.get(randVariable)[timeStep - 1];
				double[] currDistribution = multiply(prevDistribution, transitionFunctionMap.get(randVariable));
				probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = currDistribution;
			}
		}
	}
	
	/**
	 * Compute the stationary probability distribution and set it at the first time step
	 */
	public void computeStationaryDistributionAsInitial() {
		for (String randVariable : selfRandomVariableDomainMap.keySet()) {
			double[] probability = probabilityAtEachTimeStepMap.get(randVariable)[0];
			
			for (int h = 0; h <= MARKOV_CONVERGENCE_TIME_STEP; h++) {
				probability = multiply(probability, transitionFunctionMap.get(randVariable));
			}
			probabilityAtEachTimeStepMap.get(randVariable)[0] = probability;
		}
	}

	// for each agent, create probability for valueList at each timeStep of each
	// randomVariable
	// add to probabilityAtEachTimeStepMap
//	private void createAndAddProbabilityAtEachTimeStep() {
	// get each random Variable from randomVariableList
	// add to probabilityAtEachTimeStepMap
	// int columnNo = timeStepAllowed + 1;
//		int columnNo = horizon + 1;
//		for (int randVarIndex = 0; randVarIndex < selfVariableList.size(); randVarIndex++) {
//			String randVariable = selfVariableList.get(randVarIndex);
//			int domainSize = selfRandomVariableDomainMap.get(randVariable).size();
//			// each row is a timeStep from 0 to finalTimeStep
//			// each column is a value from domain
//			double[][] probAtEachTS = new double[columnNo][domainSize];
//			TransitionFunction transMatrix = transitionFunctionMap.get(randVariable);
//			for (int row = 0; row < columnNo; row++) {
//				if (row == 0) {
//					List<Double> initProbList = initProabilityMap.get(randVariable);
//					for (int col = 0; col < domainSize; col++) {
//						probAtEachTS[row][col] = initProbList.get(col);
//					}
//					continue;
//				}
//				for (int col = 0; col < domainSize; col++) {
//					double probabilityAtATime = 0;
//					for (int upperCol = 0; upperCol < domainSize; upperCol++) {
//						probabilityAtATime += probAtEachTS[row - 1][upperCol]
//								* transMatrix.getProbByIndex(upperCol, col);
//					}
//					probAtEachTS[row][col] = probabilityAtATime;
//				}
//			}
//			probabilityAtEachTimeStepMap.put(randVariable, probAtEachTS);
//		}
//	}

	public List<List<String>> getAllTupleValueOfGivenLabeUsingCartesianProduct(List<String> varLabel,
			boolean isDecVar) {
		List<Set<String>> valueSetList = new ArrayList<Set<String>>();

		for (String decisionVariable : varLabel) {
			Set<String> linkedValueSet = new LinkedHashSet<>();
			if (isDecVar) {
				linkedValueSet.addAll(decisionVariableDomainMap.get(decisionVariable));
			} else {
				linkedValueSet.addAll(selfRandomVariableDomainMap.get(decisionVariable));
			}
			valueSetList.add(linkedValueSet);
		}

		Set<List<String>> cartesianProduct = Sets.cartesianProduct(valueSetList);

		List<List<String>> finalList = new ArrayList<>();
		for (List<String> valueList : cartesianProduct) {
			finalList.add(valueList);
		}

		return finalList;
	}

	/**
	 * @param varLabel
	 * @param isDecVar
	 * @return
	 */
	public List<List<String>> getAllTupleValueOfGivenLabel(List<String> varLabel, boolean isDecVar) {
		List<List<String>> allTuple = new ArrayList<List<String>>();
		List<Integer> sizeDomainList = new ArrayList<Integer>();
		int totalDomainSize = 1;

		for (String randVar : varLabel) {
			int domainSize = 0;

			if (isDecVar) {
				domainSize = decisionVariableDomainMap.get(randVar).size();
			} else {
				domainSize = selfRandomVariableDomainMap.get(randVar).size();
			}
			sizeDomainList.add(domainSize);
			totalDomainSize *= domainSize;
		}

		int noVar = varLabel.size();

		// go from 0 to totalSize
		for (int count = 0; count < totalDomainSize; count++) {
			List<String> valueTuple = new ArrayList<String>();
			int quotient = count;
			// for each value count, decide the index of each column, then add
			// to the tuple
			for (int varIndex = noVar - 1; varIndex >= 0; varIndex--) {
				int remainder = quotient % sizeDomainList.get(varIndex);
				quotient = quotient / sizeDomainList.get(varIndex);
				if (isDecVar) {
					valueTuple.add(decisionVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
				} else {
					valueTuple.add(selfRandomVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
				}
			}
			Collections.reverse(valueTuple);
			allTuple.add(valueTuple);
		}

		return allTuple;
	}

//	public double getUtilityFromTableGivenDecAndRand(Table table, List<String> decValueList,
//			List<String> randIterationValue) {
//		List<Row> tableToTraversed = table.getRowList();
//		for (Row row : tableToTraversed) {
//			boolean isRowFound = true;
//			// System.err.println("Utility of this row " + row.getUtility());
//			List<String> rowValueList = row.getValueList();
//			List<String> rowRandomList = row.getRandomList();
//
//			if (rowValueList.size() != decValueList.size() || rowRandomList.size() != randIterationValue.size()) {
//				System.err.println("!!!!!!Different size!!!!!!!!!");
//				System.err.println("!!!!!!Recheck your code!!!!!!");
//			}
//			for (int index = 0; index < decValueList.size(); index++) {
//				if (rowValueList.get(index).equals(decValueList.get(index)) == false) {
//					isRowFound = false;
//					break;
//				}
//			}
//
//			if (isRowFound == false)
//				continue;
//
//			for (int index = 0; index < randIterationValue.size(); index++) {
//				if (rowRandomList.get(index).equals(randIterationValue.get(index)) == false) {
//					isRowFound = false;
//					break;
//				}
//			}
//
//			if (isRowFound == false)
//				continue;
//
//			return row.getUtility();
//		}
//		print("Not found!!!!!!!!!!!!!!");
//		return Integer.MIN_VALUE;
//	}

	public void sendObjectMessage(AID receiver, Object content, int msgCode) {
		ACLMessage message = new ACLMessage(msgCode);

		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		send(message);

		print("send message " + content + " to agent " + receiver.getLocalName());
	}

	public void sendStringMessage(AID receiver, String content, int msgCode) {
		ACLMessage message = new ACLMessage(msgCode);
		message.setContent(content);
		message.addReceiver(receiver);
		send(message);

		print("sends message type " + MESSAGE_TYPE.msgTypes.get(msgCode) + " to agent " + receiver.getLocalName() + ": "
				+ content);
	}

	public void sendObjectMessageWithTime(AID receiver, Object content, int msgCode, long time) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		message.setLanguage(String.valueOf(time));
		send(message);

		if (msgCode != MESSAGE_TYPE.DPOP_UTIL) {
			print("sends message type " + MESSAGE_TYPE.msgTypes.get(msgCode) + " to agent " + receiver.getLocalName()
					+ ": " + content);
		} else {
			print("sends message type " + MESSAGE_TYPE.msgTypes.get(msgCode) + " to agent " + receiver.getLocalName());
		}
	}

	public void printTree() {
		print("************");
		print("My ID is: " + agentID);
		if (!isRoot)
			print("My parent is: " + parentAID.getLocalName());
		print("My children are: ");

		for (AID children : childrenAIDSet) {
			System.out.print(children.getLocalName() + " ");
		}

		print();

		print("My pseudo_parents are: ");

		for (AID pseudoParent : pseudoParentAIDSet) {
			System.out.print(pseudoParent.getLocalName() + " ");
		}
		print();

		print("My pseudo_children are: ");
		for (AID pseudoChild : pseudoChildrenAIDSet) {
			System.out.print(pseudoChild.getLocalName() + " ");
		}
		print();
	}
	
	private void parseInputFileContinuous(String inputFileName) {
		int maxNumberOfNeighbors = Integer.MIN_VALUE;

		final String DECISION_VARIABLE = "decision";
		final String RANDOM_VARIABLE = "random";
		final String FUNCTION = "function";
		
		final String TRANS_FUNC_PREFIX = "transition";
		final String INIT_PROB_PREFIX = "initial_distribution";
		final String NEIGHBOR_SET = "neighbor set: ";

		try (BufferedReader br = new BufferedReader(
				new FileReader(System.getProperty("user.dir") + "/" +  inputFileName))) {
			List<String> lineWithSemiColonList = new ArrayList<String>();

			String line = br.readLine();
			while (line != null) {
				if (line.length() == 0 || line.startsWith("%") == true) {
					line = br.readLine();
					continue;
				}

				// concatenate line until meet ';'
				if (line.endsWith(";") == false) {
					do {
						line += br.readLine();
					} while (line.endsWith(";") == false);
				}

//				line = line.replace(" ","");
				line = line.replace(";", "");
				lineWithSemiColonList.add(line);
				line = br.readLine();
			}

			// Process line by line;
			for (String lineWithSemiColon : lineWithSemiColonList) {
				String nameMzn = lineWithSemiColon.split("=")[0];
				String valueMzn = lineWithSemiColon.split("=")[1];
				
				/** DECISION_VARIABLE */
				// read decision variable domain
				if (nameMzn.contains(DECISION_VARIABLE)) {
					// process name
					String decisionVariable = nameMzn.replace(DECISION_VARIABLE + "_x", "");

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					double lowerBound = Double.valueOf(valueMzn.split(",")[0]);
					double upperBound = Double.valueOf(valueMzn.split(",")[1]);
					decisionVariableList.add(decisionVariable);
					decisionVariableIntervalMap.put(decisionVariable, new Interval(lowerBound, upperBound));
				}
				if (nameMzn.contains(RANDOM_VARIABLE)) {
					// process name
					String randomVariable = nameMzn.replace(DECISION_VARIABLE + "_y", "");
					
					// Only add self random variable if any
					if (randomVariable.equals(agentID)) {
						// process values
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");
						double lowerBound = Double.valueOf(valueMzn.split(",")[0]);
						double upperBound = Double.valueOf(valueMzn.split(",")[1]);
						
						selfRandomVariableIntervalMap.put(randomVariable, new Interval(lowerBound, upperBound));
					}
				}

				/** FUNCTION */
				// function(x3,x1)=9.386x3^2 -5.77744x3 -3.91612x1^2 -6.10079x1 -6.70358x3x1 7.41036;
				// BinaryFunction func = new BinaryFunction(-1, 20, -3, 40, -2, 6)
				// Double.valueOf(idStr), 1.0);
				if (lineWithSemiColon.startsWith(FUNCTION)) {
					// x1^ and x10^
					if (!lineWithSemiColon.contains("x" + agentID + "^"))
						continue;

					lineWithSemiColon = lineWithSemiColon.split("=")[1];
					String[] termStrList = lineWithSemiColon.split(" ");
					String[] functionParamters = parseFunction(termStrList, "x" + agentID, lineWithSemiColon.contains("y"));
					
					// TODO: This neighbor might be a random variable
					String neighbor = functionParamters[6];
					
					MultivariateQuadFunction func = new MultivariateQuadFunction(functionParamters, agentID, neighbor);

					// Adding the new neighbor to neighborStrSet
					if (!neighbor.contains(RANDOM_PREFIX)) {
					  neighborStrSet.add(neighbor);
					}

					PiecewiseMultivariateQuadFunction pwFunc = new PiecewiseMultivariateQuadFunction();
					// creating the interval map
					Map<String, Interval> intervalMap = new HashMap<>();
					intervalMap.put("x" + agentID, globalInterval);
					intervalMap.put(neighbor, globalInterval);

					pwFunc.addToFunctionMapWithInterval(func, intervalMap, NOT_TO_OPTIMIZE_INTERVAL);
					functionMap.put(neighbor, pwFunc);

					// Own the function
					if (isRunningMaxsum() && (neighbor.contains(RANDOM_PREFIX) 
					    || compare(Double.valueOf(agentID), Double.valueOf(neighbor.replace("x", ""))) < 0)) {
						// add the function to Maxsum function map
						// add the neighbor to external-var-agent-set
						MSFunctionMapIOwn.put(neighbor, pwFunc);
					}
				}
				
				if (lineWithSemiColon.startsWith(NEIGHBOR_SET)) {
					lineWithSemiColon = lineWithSemiColon.replace(NEIGHBOR_SET, "");
					lineWithSemiColon = lineWithSemiColon.replace("x", "");
					String[] agentWithNeighbors = lineWithSemiColon.split(" ");
					// 3: 1 4 5
					if (agentWithNeighbors.length - 1 > maxNumberOfNeighbors) {
						maxNumberOfNeighbors = agentWithNeighbors.length - 1;
//						rootAgent = Integer.parseInt(agentWithNeighbors[0].replaceAll(":", ""));
						rootAgent = agentWithNeighbors[0].replaceAll(":", "");
					}
				}
				
        if (nameMzn.contains(INIT_PROB_PREFIX)) {
          nameMzn = nameMzn.replace(INIT_PROB_PREFIX + "_y", "");

          // Read variable with agentID only
          if (!nameMzn.equals(agentID)) {
            continue;
          }

          // process values
          valueMzn = valueMzn.replace("[", "");
          valueMzn = valueMzn.replace("]", "");

          // alpha=1.2,beta=3.4565
          double alpha = Double.valueOf(valueMzn.split(",")[0].replace("alpha=", ""));
          double beta = Double.valueOf(valueMzn.split(",")[1].replace("beta=", ""));
          
          RandomGenerator rg = new Well19937c(DEFAULT_BETA_SAMPLING_SEED);
          setInitialDistribution(new BetaDistribution(rg, alpha, beta));
        }
        
        if (nameMzn.contains(TRANS_FUNC_PREFIX)) {
          nameMzn = nameMzn.replace(TRANS_FUNC_PREFIX + "_y", "");

          // Read variable with agentID only
          if (!nameMzn.equals(agentID)) {
            continue;
          }

          // process values
          valueMzn = valueMzn.replace("[", "");
          valueMzn = valueMzn.replace("]", "");

          // alpha=1.2
          double alpha = Double.valueOf(valueMzn.replace("alpha=", ""));
          setTransitionDistribution(TransitionFamilyDistribution.of(alpha));
        }
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void parseInputFileDiscrete(String inputFileName) {
		final String DECISION_VARIABLE = "decision";
		final String RANDOM_VARIABLE = "random";
		final String REWARD_TABLE_PREFIX = "constraint";
		final String TRANS_FUNC_PREFIX = "transition";
		final String INIT_PROB_PREFIX = "initial_distribution";

		Map<String, Set<String>> neighborSetMap = new HashMap<>();
		Map<String, Integer> randHeuristicMap = new HashMap<>();
		Set<String> allRandomVariableSet = new HashSet<>();

		try (BufferedReader br = new BufferedReader(
				new FileReader(System.getProperty("user.dir") + '/' + inputFileName))) {
			List<String> lineWithSemiColonList = new ArrayList<String>();

			String line = br.readLine();
			while (line != null) {
				if (line.length() == 0 || line.startsWith("%") == true) {
					line = br.readLine();
					continue;
				}

				// concatenate lines until meet ';'
				if (!line.endsWith(";")) {
					do {
						line += br.readLine();
					} while (line.endsWith(";") == false);
				}

				line = line.replace(" ", "");
				line = line.replace(";", "");

//				if (isPrinting()) {
//          print(line);
//        }

				lineWithSemiColonList.add(line);
				line = br.readLine();
			}

			// Process line by line;
			for (String lineWithSemiColon : lineWithSemiColonList) {
				// print input file for agent0
				String nameMzn = lineWithSemiColon.split("=")[0];
				String valueMzn = lineWithSemiColon.split("=")[1];

				/** DECISION_VARIABLE */
				// read decision variable domain
				if (nameMzn.contains(DECISION_VARIABLE)) {
					// process name
					String decisionVariable;
					List<String> valueOfDecisionVariableList = new ArrayList<>();
					decisionVariable = nameMzn.replace(DECISION_VARIABLE + "_x", "");

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					for (int value = Integer.parseInt(valueMzn.split(",")[0]); value <= Integer
							.parseInt(valueMzn.split(",")[1]); value++) {
						valueOfDecisionVariableList.add(String.valueOf(value));
					}

					decisionVariableList.add(decisionVariable);
					decisionVariableDomainMap.put(decisionVariable, valueOfDecisionVariableList);

//          if (isPrinting()) {
//            print("decisionVariableList " + decisionVariableList);
//            print("decisionVariableDomainMap " + decisionVariableDomainMap);
//          }
				}
				/** RANDOM_VARIABLE */
				// read decision variable domain
				if (nameMzn.contains(RANDOM_VARIABLE)) {
					// process name
					String randomVariable;
					List<String> randomDomain = new ArrayList<>();
					randomVariable = nameMzn.replace(RANDOM_VARIABLE + "_y", "");

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					for (int value = Integer.parseInt(valueMzn.split(",")[0]); value <= Integer
							.parseInt(valueMzn.split(",")[1]); value++) {
						randomDomain.add(String.valueOf(value));
					}

					allRandomVariableSet.add(randomVariable);

					boundDpopRandomDomains.put(randomVariable, randomDomain);

					// Only add self random variable if any
					if (randomVariable.equals(agentID)) {
						selfRandomVariableDomainMap.put(randomVariable, randomDomain);
					}

//          if (isPrinting()) {
//            print("randomVariableDomainMap " + selfRandomVariableDomainMap);
//          }
				}
				/** TRANS_FUNC_PREFIX */
				if (nameMzn.contains(TRANS_FUNC_PREFIX)) {
					String randomVariable;
					List<List<Double>> newTransitionMatrix;

					randomVariable = nameMzn.replaceAll(TRANS_FUNC_PREFIX + "_y", "");

					// Read variables related to agentID only
					if (!randomVariable.equals(agentID)) {
						continue;
					}

					/** create transition function **/
					newTransitionMatrix = new ArrayList<List<Double>>();
					List<String> listOfRow;
					/** process table values **/
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
//					valueMzn = valueMzn.substring(1, valueMzn.length() - 1);
					listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
					for (String oneRow : listOfRow) {
						List<String> valueStrList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
						List<Double> valueDoubleList = new ArrayList<Double>();

						for (String valueStr : valueStrList) {
							valueDoubleList.add(Double.parseDouble(valueStr));
						}
						newTransitionMatrix.add(valueDoubleList);
					}
					TransitionFunction newTransitionFunction = new TransitionFunction(
							selfRandomVariableDomainMap.get(randomVariable), newTransitionMatrix);
					transitionFunctionMap.put(randomVariable, newTransitionFunction);

//          if (isPrinting()) {
//            print("transitionFunctionMap " + transitionFunctionMap);
//          }
				}
				/** INIT_PROB_PREFIX */
				if (nameMzn.contains(INIT_PROB_PREFIX)) {
					String randomVariable;
					List<String> initProbabilityStrList;
//					List<Double> initProbabilityDoubleList = new ArrayList<Double>();
					nameMzn = nameMzn.replace(INIT_PROB_PREFIX + "_y", "");
					randomVariable = nameMzn;

//					 Read variable with agentID only
					if (!randomVariable.equals(agentID)) {
						continue;
					}

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					initProbabilityStrList = new ArrayList<>(Arrays.asList(valueMzn.split(",")));

					int randomDomainSize = initProbabilityStrList.size();
					probabilityAtEachTimeStepMap.put(randomVariable, new double[horizon + 1][randomDomainSize]);

					for (int i = 0; i < initProbabilityStrList.size(); i++) {
						probabilityAtEachTimeStepMap.get(randomVariable)[0][i] = Double
								.parseDouble(initProbabilityStrList.get(i));
					}

//          if (isPrinting()) {
//            print("initProabilityMap " + Arrays.toString(probabilityAtEachTimeStepMap.get(randomVariable)[0]));
//          }
				}
				/** REWARD_TABLE_PREFIX */
				/**
				 * process name of constraint table, create table with the corresponding name
				 **/
				if (nameMzn.contains(REWARD_TABLE_PREFIX)) {
					nameMzn = nameMzn.replaceAll(REWARD_TABLE_PREFIX + "_", "");

					Table newRewardTable;
					List<String> variableLabel = new ArrayList<String>(Arrays.asList(nameMzn.split("_")));
					List<String> listOfRow;

					// Do not add random variables to the neighbor list
					if (!nameMzn.contains("y")) {
						String var1 = variableLabel.get(0).replace("x", "");
						String var2 = variableLabel.get(1).replace("x", "");

						neighborSetMap.computeIfAbsent(var1, x -> new HashSet<>()).add(var2);
						neighborSetMap.computeIfAbsent(var2, x -> new HashSet<>()).add(var1);
					}

					if (!variableLabel.contains("x" + agentID)) {
						continue;
					}
					/**** WITHOUT random variable **********/
					boolean notContainRandom = true;
					for (String var : variableLabel) {
						if (var.contains("y")) {
							notContainRandom = false;
							break;
						}
					}
					if (notContainRandom) {
						/** add variable to neighborList **/
						List<String> variableLabel_new = new ArrayList<>();
						for (String var : variableLabel) {
							/* add to neighbor list */
							var = var.replace("x", "");
							if (!var.equals(agentID) && !neighborStrSet.contains(var)) {
								neighborStrSet.add(var);
							}
							variableLabel_new.add(var);
						}
						/** create Table **/
						newRewardTable = new Table(variableLabel_new, DECISION_TABLE);

						/** process table values **/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");

						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));

						for (String oneRow : listOfRow) {
							List<String> valueList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
							double utility = Double.parseDouble(valueList.get(valueList.size() - 1));
							valueList.remove(valueList.size() - 1);
							Row newRow = new Row(valueList, utility);
							newRewardTable.addRow(newRow);
						}
//						constraintTableWithoutRandomList.add(newRewardTable);
						rawDecisionTableList.add(newRewardTable);
//						
//	          if (isPrinting()) {
//	            print("rawDecisionTableList " + rawDecisionTableList);
//	          }
					}
					/**** WITH random variable **********/
					else {
						/** Process nameMzn */
						int decisionVarCount = 0;
						List<String> decVarLabel = new ArrayList<String>();
						List<String> randVarLabel = new ArrayList<String>();
						for (String var : variableLabel) {
							if (var.startsWith("x")) {
								decisionVarCount++;
								decVarLabel.add(var.replace("x", ""));
							} else if (var.startsWith("y")) {
								randVarLabel.add(var.replace("y", ""));
							}
						}
						/** add variable to neighborList **/
						for (String var : decVarLabel) {
							/* add to neighbor list */
							if (!var.equals(agentID)) {
								neighborStrSet.add(var);
							}
						}
						/** create Table **/
						// print("!" + decVarLabel + " " +
						// randVarLabel);
						newRewardTable = new Table(decVarLabel, randVarLabel, RANDOM_TABLE);

						/** process table values **/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");
						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
						for (String oneRow : listOfRow) {
							List<String> decAndRandValueList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
							List<String> decValueList = new ArrayList<String>();
							List<String> randValueList = new ArrayList<String>();
							double utility = Double
									.parseDouble(decAndRandValueList.get(decAndRandValueList.size() - 1));

							decAndRandValueList.remove(decAndRandValueList.size() - 1);
							for (int i = 0; i < decisionVarCount; i++) {
								decValueList.add(decAndRandValueList.get(i));
							}
							for (int i = decisionVarCount; i < decAndRandValueList.size(); i++) {
								randValueList.add(decAndRandValueList.get(i));
							}
							Row newRow = new Row(decValueList, randValueList, utility);
							newRewardTable.addRow(newRow);
						}
						rawRandomTableList.add(newRewardTable);
//            if (isPrinting()) {
//              print("rawRandomTableList " + rawRandomTableList);
//            }
					}
				}
			}

			// Compute randHeuristicMap
			for (Entry<String, Set<String>> entry : neighborSetMap.entrySet()) {
				String agent = entry.getKey();
				int count = 0;
				for (String neighbor : entry.getValue()) {
					if (allRandomVariableSet.contains(neighbor)) {
						count++;
					}
				}

				randHeuristicMap.put(agent, count);
			}
//			randomCount = allRandomVariableSet.size();

			// Compute heuristic values for each agent
			SortedSet<String> allAgents = new TreeSet<>(neighborSetMap.keySet());
			double maxValue = -Double.MAX_VALUE;
//			print("AgentID=" + agentID + " has neighborSetMap=" + neighborSetMap);

			for (String agent : allAgents) {
				int agentRandHeuristic = (allRandomVariableSet.contains(agent) ? 1 + 1 : 1 + 0)
						* randHeuristicMap.get(agent);
				double value = heuristicWeight * agentRandHeuristic
						+ (1 - heuristicWeight) * neighborSetMap.get(agent).size();
				agentHeuristicStringMap.put(agent, value);

				if (Double.compare(value, maxValue) > 0) {
					maxValue = value;
					rootAgent = agent;
				}
			}
			/** Place to test printing out */
			/** end of testing */
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public boolean isRunningMaxsum() {
		return dcop_algorithm == DcopAlgorithm.MAXSUM || dcop_algorithm == DcopAlgorithm.HYBRID_MAXSUM || dcop_algorithm == DcopAlgorithm.CAF_MAXSUM;
	}
	
	// 9.386x3^2 -5.77744x3 -3.91612x1^2 -6.10079x1 -6.70358x3x1 7.41036
	// 9.386x3^2 -5.77744x3 -3.91612y3^2 -6.10079y3 -6.70358x3y3 7.41036
	public String[] parseFunction(String[] termArray, String selfAgent, boolean hasRandom) {
		String coeffArray[] = new String[7];
		Arrays.fill(coeffArray, null);
		
		String neighbor = "";
		
		String otherVarPrefix = hasRandom ? "y" : "x";
		
		for (String term : termArray) {
			// -281x1^2
			if (term.contains(selfAgent + "^2")) {
				coeffArray[0] = term.replace(selfAgent + "^2", "");
			}
			// -22x10^2
			// -22y10^2
			else if (term.contains("^2")) {
				term = term.replace("^2", "");
				coeffArray[2] = term.split(otherVarPrefix)[0];
				
				// neighbor
				neighbor = otherVarPrefix + term.split(otherVarPrefix)[1];
				coeffArray[6] = neighbor;
			}
			// constant 358
			else if (!term.contains("x") && !term.contains("y")) {
				coeffArray[5] = term;

			}
			// 288x1x10 OR 252x10 OR 199x1
			// 288x1y10 OR 252y10 OR 199x1
			// split the "x_"
			// count for number of element
			// then comparing number
			// done
			else {
				// 288x1x10 or 288x1y10
				if (term.contains(selfAgent + neighbor) || term.contains(neighbor + selfAgent)) {
					coeffArray[4] = term.split("x")[0]; // assuming that x stands before y
				}
				// 199x1 OR 199x10 OR 199y1 OR 199y10
				else if (term.endsWith(selfAgent)) {
					coeffArray[1] = term.replace(selfAgent, "");
				}
				else {
					coeffArray[3] = term.replace(neighbor, "");
				}
			}
		}
		
		return coeffArray;
	}

	public boolean isPrinting() {
		return agentID.equals("2");
	}

	public void registerWithDF() {
		DFAgentDescription dfd = new DFAgentDescription();
		dfd.setName(getAID());

		for (String neighborStr : neighborStrSet) {
			ServiceDescription sd = new ServiceDescription();
			sd.setType(neighborStr);
			sd.setName(agentID);
			dfd.addServices(sd);
		}

//		for (int i = 0; i < neighborStrSet.size(); i++) {
//			ServiceDescription sd = new ServiceDescription();
//			sd.setType(neighborStrSet.get(i));
//			sd.setName(agentID);
//			dfd.addServices(sd);
//		}

		try {
			DFService.register(this, dfd);
		} catch (FIPAException fe) {
			fe.printStackTrace();
		}
	}

	/**
	 * @return the actual local solution quality at the subtree in ACTUAL_UTIL phase
	 */
	public double computeActualUtilityWithParentAndPseudoParent() {
		double sumUtility = 0;

		for (int ts = 0; ts < chosenValueAtEachTSMap.size(); ts++) {
			List<Table> tableList = actualDpopTableAcrossTimeStep.get(ts);

			for (Table constraintTable : tableList) {
				List<String> decisionLabel = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();

				for (String variableInLabel : decisionLabel) {
					if (variableInLabel.equals(agentID)) {
						decValueList.add(chosenValueAtEachTSMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(variableInLabel).get(ts));
					}
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}

		return sumUtility;
	}

	/**
	 * REVIEWED <br>
	 * 
	 * Get utility with parents and pseudoparents, then add its switching cost
	 * 
	 * @param timeSteps
	 * @return
	 */
	public double utilityLSWithParentAndPseudoAndUnary() {
		double sumUtility = 0;

		for (int ts = 0; ts <= horizon; ts++) {
			List<Table> tableList = discountedExpectedTableEachTSMap.get(ts);

			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();

				// Only consider tables with parent and pseudo-parents
				// And unary constraint
				List<String> decLabelMinusAgent = new ArrayList<String>(decVarList);
				decLabelMinusAgent.remove(agentID);
				if (!parentAndPseudoStrList.containsAll(decLabelMinusAgent)) {
					continue;
				}

				for (String variableInList : decVarList) {
					if (variableInList.equals(agentID)) {
						decValueList.add(chosenValueAtEachTSMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(variableInList).get(ts));
					}
				}

				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}

		return sumUtility;
	}

	public List<String> getSelfDomain() {
		return decisionVariableDomainMap.get(agentID);
	}

	/**
	 * REVIEWED <br>
	 * 
	 * Return switching cost in positive values
	 * 
	 * @return
	 */
	public double computeSwitchingCostAllTimeStep() {
		double switchingCost = 0;

		if (chosenValueAtEachTSMap.size() == 1) {
			return Double.MAX_VALUE;
		}

		// Compute switching costs from the first time step to the horizon
		for (int timeStep = 0; timeStep < horizon; timeStep++) {
			switchingCost += Math.pow(discountFactor, timeStep) * switchingCostFunction(
					chosenValueAtEachTSMap.get(timeStep), chosenValueAtEachTSMap.get(timeStep + 1));
		}

		return switchingCost;
	}

	/**
	 * Return switching cost in 0 or negative value <br>
	 * If the second argument is null, then return 0
	 * 
	 * @param oldValue
	 * @param newValue
	 * @return
	 */
	public double switchingCostFunction(String oldValue, String newValue) {
		if (oldValue == null || newValue == null) {
			return -Double.MAX_VALUE;
		}
		if (oldValue.isEmpty() || newValue.isEmpty()) {
			return -Double.MAX_VALUE;
		}

		boolean equal = oldValue.equals(newValue);

		double difference = Math.abs(Double.parseDouble(oldValue) - Double.parseDouble(newValue));

		switch (SWITCHING_TYPE) {
		case CONSTANT:
			return equal ? 0 : switchingCost;
		case LINEAR:
			return equal ? 0 : switchingCost * difference;
		case QUADRATIC:
			return equal ? 0 : switchingCost * Math.pow(difference, 2);
		case EXP_2:
			return equal ? 0 : switchingCost * Math.pow(2, difference);
		case EXP_3:
			return equal ? 0 : switchingCost * Math.pow(3, difference);
		}

		return -Double.MAX_VALUE;
	}

	/**
	 * REVIEWED <br>
	 * Has taken into account the sum of discounted utility when FINITE and timeStep
	 * = horizon
	 * 
	 * @param decisionTableList
	 * @param timeStep
	 * @param discountFactor
	 * @return
	 */
	public List<Table> computeDiscountedDecisionTableList(List<Table> decisionTableList, int timeStep, double df) {
		List<Table> tableList = new ArrayList<>();

		for (Table decisionTable : decisionTableList) {
			tableList.add(computeDiscountedDecisionTable(decisionTable, timeStep, df));
		}
		return tableList;
	}

	/**
	 * REVIEWED <br>
	 * 
	 * @param randomTableList
	 * @param timeStep
	 * @param df
	 * @return
	 */
	public List<Table> computeDiscountedExpectedRandomTableList(List<Table> randomTableList, int timeStep, double df) {
		List<Table> tableList = new ArrayList<>();

		for (Table randomTable : randomTableList) {
			tableList.add(computeDiscountedExpectedTable(randomTable, timeStep, df));
		}
		return tableList;
	}

	/**
	 * REVIEWED <br>
	 * 
	 * @param inputRandomTable
	 * @param timeStep
	 * @param discountFactor
	 * @return
	 */
	public Table computeDiscountedExpectedTable(Table inputRandomTable, int timeStep, double df) {
		Table randomTable = inputRandomTable;

		if (dynamicType == DynamicType.FINITE_HORIZON && timeStep == horizon) {
			randomTable = computeLongtermExpectedTable(randomTable, timeStep, df);
		}

		List<String> decLabel = randomTable.getDecVarLabel();
		List<String> randLabel = randomTable.getRandVarLabel();
		Table discountedExpectedTable = new Table(decLabel, RANDOM_TABLE);

		int randDomainSize = 1;
		for (String randVar : randLabel) {
			randDomainSize *= selfRandomVariableDomainMap.get(randVar).size();
		}

		double expectedUtility = 0;
		// assume all rows contain a given value combination of decision variables are
		// next to each other
		// thus we can traverse in that order to compute the expected utilities from
		// random variable values
		for (int index = 0; index < randomTable.getRowCount(); index++) {
			Row row = randomTable.getRowList().get(index);

			List<String> decValueList = row.getValueList();
			List<String> randValueList = row.getRandomList();
			double jointProbability = 1;

			for (int idx = 0; idx < randLabel.size(); idx++) {
				String randomVar = randLabel.get(idx);
				String randomValue = randValueList.get(idx);

				jointProbability *= probabilityAtEachTimeStepMap.get(randomVar)[timeStep][selfRandomVariableDomainMap
						.get(randomVar).indexOf(randomValue)];
			}
			expectedUtility += jointProbability * row.getUtility();

			// last turn when traverse to the last value of the random variable(s)
			if (index % randDomainSize == randDomainSize - 1) {
				Row newRow = new Row(decValueList, expectedUtility * Math.pow(df, timeStep));
				discountedExpectedTable.addRow(newRow);
				expectedUtility = 0; // reset the expected value for the next decision variable value combination
			}
			// end of traversing row
		}

		return discountedExpectedTable;
	}

	/**
	 * REVIEWED <br>
	 * Used for FINITE_HORIZON at the horizon only
	 * 
	 * @param randomTable
	 * @param timeStep
	 * @return
	 */
	public Table computeLongtermExpectedTable(Table randomTable, int timeStep, double df) {
		Set<List<String>> processedDecValues = new HashSet<List<String>>();

		List<String> decVarLabel = randomTable.getDecVarLabel();
		List<String> randVarLabel = randomTable.getRandVarLabel();

		List<List<String>> allTupleValue = getAllTupleValueOfGivenLabeUsingCartesianProduct(randVarLabel, false);

		Table newlyCreatedTable = new Table(decVarLabel, randVarLabel, RANDOM_TABLE);

		int noOfEquations = 1;
		for (String randVar : randVarLabel) {
			noOfEquations *= selfRandomVariableDomainMap.get(randVar).size();
		}

		// traverse each row of tableWithRandom
		for (Row rowToBeTraversed : randomTable.getRowList()) {
			List<String> decValueList = rowToBeTraversed.getValueList();

			// check if decValueList contained in processedDecValues
			if (processedDecValues.contains(decValueList)) {
				continue;
			}
			// search for all values of random Variable
			else {
				processedDecValues.add(decValueList);
				/**
				 * construct unknown equations, by add coefficients
				 *
				 * construct coefficients (1-delta*prob[0,0] - delta*prob[0,1] ... -
				 * delta*prob[0,n] = v0 -delta*prob[1,0] + (1-delta*prob[1,1] ...-
				 * delta*prob[1,n] = v1
				 *
				 * -delta*prob[n,0] - delta*prob[n,1] ... + (1-delta*prob[n,n] = v_n
				 **/
				double coefficients[][] = new double[noOfEquations][noOfEquations + 1];
				// select rowTuple => colTuple
				for (int row = 0; row < noOfEquations; row++) {
					List<String> rowTuple = allTupleValue.get(row);
					// get colTuple
					for (int column = 0; column < noOfEquations; column++) {
						List<String> colTuple = allTupleValue.get(column);
						double transProb = 1;
						for (int randIndex = 0; randIndex < randVarLabel.size(); randIndex++) {
							String randVar = randVarLabel.get(randIndex);
							transProb = transProb * transitionFunctionMap.get(randVar)
									.getProbByValue(rowTuple.get(randIndex), colTuple.get(randIndex));
						}

						if (row == column) {
							coefficients[row][column] = 1 - df * transProb;
						} else {
							coefficients[row][column] = -df * transProb;
						}
					}
					// set utility
					coefficients[row][noOfEquations] = Math.pow(df, timeStep)
							* randomTable.getUtilityFromTableGivenDecAndRand(decValueList, rowTuple);
				}

				// print(Arrays.deepToString(coefficients));
				List<Double> utilityList = gaussian(coefficients, noOfEquations);

				// create new row with a fix dec values, but different rand values
				int i = 0;
				for (List<String> randValueToBeAddedList : allTupleValue) {
					Row newRow = new Row(decValueList, randValueToBeAddedList, utilityList.get(i));
					i++;
					newlyCreatedTable.addRow(newRow);
				}
				// end if: decValueList not contained
			}
			// end while: traversing table
		}
		return newlyCreatedTable;
	}

	private List<Double> gaussian(double arr[][], int N) {
		List<Double> longtermUtilityList = new ArrayList<Double>();
		// take each line as pivot, except for the last line
		for (int pivotIndex = 0; pivotIndex < N - 1; pivotIndex++) {
			// go from the line below line pivotIndex, to the last line
			boolean isNotZeroRowFound = false;
			if (arr[pivotIndex][pivotIndex] == 0) {
				int notZeroRow;
				for (notZeroRow = pivotIndex + 1; notZeroRow < N; notZeroRow++) {
					if (arr[notZeroRow][pivotIndex] != 0) {
						isNotZeroRowFound = true;
						break;
					}
				}

				if (isNotZeroRowFound) {
					// swap row pivotIndex and row notZeroRow
					for (int columnToSwapIndex = 0; columnToSwapIndex < N + 1; columnToSwapIndex++) {
						double tempForSwap = arr[pivotIndex][columnToSwapIndex];
						arr[pivotIndex][columnToSwapIndex] = arr[notZeroRow][columnToSwapIndex];
						arr[notZeroRow][columnToSwapIndex] = tempForSwap;
					}
				} else {
					continue;
				}
			}

			for (int rowForGauss = pivotIndex + 1; rowForGauss < N; rowForGauss++) {
				double factor = arr[rowForGauss][pivotIndex] / arr[pivotIndex][pivotIndex];
				for (int columnForGauss = 0; columnForGauss < N + 1; columnForGauss++) {
					arr[rowForGauss][columnForGauss] = arr[rowForGauss][columnForGauss]
							- factor * arr[pivotIndex][columnForGauss];
				}
			}
		}

		for (int columnPivot = N - 1; columnPivot >= 1; columnPivot--) {
			for (int rowAbovePivot = columnPivot - 1; rowAbovePivot >= 0; rowAbovePivot--) {
				double fraction = arr[rowAbovePivot][columnPivot] / arr[columnPivot][columnPivot];
				for (int columnInTheRow = 0; columnInTheRow < N + 1; columnInTheRow++)
					arr[rowAbovePivot][columnInTheRow] = arr[rowAbovePivot][columnInTheRow]
							- fraction * arr[columnPivot][columnInTheRow];
			}
		}

		for (int i = 0; i < N; i++) {
			longtermUtilityList.add(arr[i][N] / arr[i][i]);
		}

		return longtermUtilityList;
	}

	/**
	 * REVIEWED <br>
	 * Compute discounted or sum of discounted
	 * 
	 * @param decisionTable
	 * @param timeStep
	 * @param discountFactor
	 * @return
	 */
	public Table computeDiscountedDecisionTable(Table decisionTable, int timeStep, double df) {
		if (decisionTable == null) {
			return null;
		}

		Table discountedTable = new Table(decisionTable.getDecVarLabel(), DECISION_TABLE);

		for (Row decisionTableRow : decisionTable.getRowList()) {
			List<String> valueList = decisionTableRow.getValueList();
			double utility = decisionTableRow.getUtility();

			// Horizon with FINITE
			if (dynamicType == DynamicType.FINITE_HORIZON && timeStep == horizon) {
				discountedTable.addRow(new Row(valueList, utility * Math.pow(df, timeStep) / (1 - df)));
			} else {
				discountedTable.addRow(new Row(valueList, utility * Math.pow(df, timeStep)));
			}
		}
		return discountedTable;
	}

	/**
	 * REVIEWED
	 * 
	 * @param randomTableList
	 * @param lastTimeStep
	 * @param df
	 * @return
	 */
	public List<Table> computeCollapsedRandomTableList(List<Table> randomTableList, int lastTimeStep, double df) {
		List<Table> collapedDecistionTableList = new ArrayList<>();
		for (Table randomTable : randomTableList) {
			List<Table> similarTableList = new ArrayList<>();

			for (int timeStep = 0; timeStep <= lastTimeStep; timeStep++) {
				similarTableList.add(computeDiscountedExpectedTable(randomTable, timeStep, discountFactor));
			}

			collapedDecistionTableList.add(computeCollapsedTableFromList(similarTableList, AgentPDDCOP.RANDOM_TABLE));
		}

		return collapedDecistionTableList;
	}

	/**
	 * NOT REVIEWED BUT TESTED <br>
	 * They have the same entry, only different in utilities
	 * 
	 * @param tableList
	 * @param isRandTable
	 * @return
	 */
	public Table computeCollapsedTableFromList(List<Table> tableList, boolean isRandTable) {
		if (tableList.size() == 0) {
			return null;
		}
		Table joinedTable = new Table(tableList.get(0).getDecVarLabel(), isRandTable);

		int variableCount = tableList.get(0).getDecVarLabel().size();
		int rowCount = tableList.get(0).getRowCount();
		int tableCount = tableList.size();
		int totalRowCount = (int) Math.pow(rowCount, tableCount);

		for (int count = 0; count < totalRowCount; count++) {
			List<String> valueTuple = new ArrayList<>(variableCount);
			for (int i = 0; i < variableCount; i++) {
				valueTuple.add("");
			}

			double sumUtility = 0;
			int quotient = count;
			// for each table count, decide the index of each column, then add to the tuple
			for (int tableIndex = tableCount - 1; tableIndex >= 0; tableIndex--) {
				int remainder = quotient % rowCount;
				quotient = quotient / rowCount;

				Row row = tableList.get(tableIndex).getRowList().get(remainder);
				sumUtility += row.getUtility();
				List<String> valueList = row.getValueList();

				for (int idx = 0; idx < valueList.size(); idx++) {
					valueTuple.set(idx, valueList.get(idx) + "," + valueTuple.get(idx));
				}
			}

			for (int idx = 0; idx < valueTuple.size(); idx++) {
				valueTuple.set(idx, valueTuple.get(idx).substring(0, valueTuple.get(idx).length() - 1));
			}

			joinedTable.addRow(new Row(valueTuple, sumUtility));
		}

		return joinedTable;
	}

	/**
	 * REVIEWED
	 * 
	 * @param decisionTableList
	 * @param lastTimeStep
	 * @param discountFactor
	 * @return
	 */
	public List<Table> computeCollapsedDecisionTableList(List<Table> decisionTableList, int lastTimeStep, double df) {
		List<Table> collapedDecistionTableList = new ArrayList<>();

		// For each table, compute a list of similar tables that are only different in
		// utilities
		for (Table decTable : decisionTableList) {
			List<Table> similarTableList = new ArrayList<>();

			for (int timeStep = 0; timeStep <= lastTimeStep; timeStep++) {
				similarTableList.add(computeDiscountedDecisionTable(decTable, timeStep, df));
			}

			collapedDecistionTableList.add(computeCollapsedTableFromList(similarTableList, AgentPDDCOP.DECISION_TABLE));
		}

		return collapedDecistionTableList;
	}

	/**
	 * REVIEWED <br>
	 * Compute unary switching cost table given domain and a number of time step
	 * 
	 * @param domain
	 * @param lastTimeStep
	 * @return
	 */
	public Table computeCollapsedSwitchingCostTable(List<String> domain, int lastTimeStep, double df) {
		List<String> label = new ArrayList<>();
		label.add(agentID);

		Table collapsedSwitchingCostTable = new Table(label, AgentPDDCOP.DECISION_TABLE);

		List<Set<String>> domainSetList = new ArrayList<Set<String>>();
		for (int timeIndex = 0; timeIndex <= lastTimeStep; timeIndex++) {
			domainSetList.add(new LinkedHashSet<>(domain));
		}

		Set<List<String>> productValues = Sets.cartesianProduct(domainSetList);

		for (List<String> valueList : productValues) {
			double sCost = 0D;

			String valueListString = "";
			for (int i = 0; i < valueList.size() - 1; i++) {
				sCost += Math.pow(df, i) * switchingCostFunction(valueList.get(i), valueList.get(i + 1));
				valueListString += valueList.get(i) + ",";
			}
			valueListString += valueList.get(valueList.size() - 1);

			List<String> finalValueWithCommas = new ArrayList<>();
			finalValueWithCommas.add(valueListString);

			// Add the switching cost from horizon h-1 to h if the value is not null
			// If the value is null, the
			if (lastTimeStep == horizon - 1) {
				sCost += Math.pow(df, horizon - 1)
						* switchingCostFunction(valueList.get(horizon - 1), chosenValueAtEachTSMap.get(horizon));
			}

			collapsedSwitchingCostTable.addRow(new Row(finalValueWithCommas, -sCost));
		}

		return collapsedSwitchingCostTable;
	}

	public String getAgentID() {
		return agentID;
	}

	public boolean isRoot() {
		return isRoot;
	}

	public boolean isLeaf() {
		return isLeaf;
	}

	public void setLeaf(boolean isLeaf) {
		this.isLeaf = isLeaf;
	}

	public Set<AID> getNeighborAIDSet() {
		return neighborAIDSet;
	}

	public void setNeighborAIDSet(Set<AID> neighborAIDSet) {
		this.neighborAIDSet = neighborAIDSet;
	}

	public Set<String> getNeighborStrSet() {
		return neighborStrSet;
	}

	public void setNeighborStrSet(Set<String> neighborStrSet) {
		this.neighborStrSet = neighborStrSet;
	}

	public boolean isNotVisited() {
		return notVisited;
	}

	public void setNotVisited(boolean notVisited) {
		this.notVisited = notVisited;
	}

	public Set<AID> getChildrenAIDSet() {
		return childrenAIDSet;
	}

	public void setChildrenAIDList(Set<AID> childrenAIDSet) {
		this.childrenAIDSet = childrenAIDSet;
	}

	public AID getParentAID() {
		return parentAID;
	}

	public void setParentAID(AID parentAID) {
		this.parentAID = parentAID;
	}

	public List<String> getParentAndPseudoStrList() {
		return parentAndPseudoStrList;
	}

	public void setParentAndPseudoStrList(List<String> parentAndPseudoStrList) {
		this.parentAndPseudoStrList = parentAndPseudoStrList;
	}

	public Set<AID> getPseudoChildrenAIDSet() {
		return pseudoChildrenAIDSet;
	}

	public void setPseudoChildrenAIDSet(Set<AID> pseudoChildrenAIDSet) {
		this.pseudoChildrenAIDSet = pseudoChildrenAIDSet;
	}

	public Set<AID> getPseudoParentAIDList() {
		return pseudoParentAIDSet;
	}

	public void setPseudoParentAIDList(Set<AID> pseudoParentAIDSet) {
		this.pseudoParentAIDSet = pseudoParentAIDSet;
	}

	public ThreadMXBean getBean() {
		return bean;
	}

	public void setBean(ThreadMXBean bean) {
		this.bean = bean;
	}

	public long getCurrentStartTime() {
		return currentStartTime;
	}

	public void setCurrentStartTime(long currentStartTime) {
		this.currentStartTime = currentStartTime;
	}

	public HashMap<String, List<String>> getDecisionVariableDomainMap() {
		return decisionVariableDomainMap;
	}

	public void setDecisionVariableDomainMap(HashMap<String, List<String>> decisionVariableDomainMap) {
		this.decisionVariableDomainMap = decisionVariableDomainMap;
	}

	public String getChosenValueAtEachTimeStep(int timeStep) {
		return chosenValueAtEachTSMap.getOrDefault(timeStep, null);
	}

	public void setChosenValueAtEachTimeStep(int timeStep, String chosenValue) {
		this.chosenValueAtEachTSMap.put(timeStep, chosenValue);
	}

	public Map<Integer, String> getChosenValueAtEachTSMap() {
		return this.chosenValueAtEachTSMap;
	}

	public void setValueAtTimeStep(int timeStep, String value) {
		this.chosenValueAtEachTSMap.put(timeStep, value);
	}

	public long getSimulatedTime() {
		return simulatedTime;
	}

	public void setSimulatedTime(long simulatedTime) {
		this.simulatedTime = simulatedTime;
	}

	public void addupSimulatedTime(long time) {
		this.simulatedTime += time;
	}

	public HashMap<Integer, List<Table>> getDiscountedExpectedTableEachTSMap() {
		return discountedExpectedTableEachTSMap;
	}

	public Table getAgentViewTable() {
		return agentViewTable;
	}

	public void setAgentViewTable(Table agentViewTable) {
		this.agentViewTable = agentViewTable;
	}

	public List<Double> getCurrentGlobalUtilityList() {
		return currentGlobalUtilityList;
	}

	public void setCurrentGlobalUtilityList(List<Double> currentGlobalUtilityList) {
		this.currentGlobalUtilityList = currentGlobalUtilityList;
	}

	public double getSolutionQuality() {
		return solutionQuality;
	}

	public void setSolutionQuality(double solutionQuality) {
		this.solutionQuality = solutionQuality;
	}

	public void increaseSolutionQuality(double quality) {
		this.solutionQuality += quality;
	}

	public static long getDelayMessageTime() {
		return delayMessageTime;
	}

	public static void setDelayMessageTime(long delayMessageTime) {
		AgentPDDCOP.delayMessageTime = delayMessageTime;
	}

	public Map<String, HashMap<Integer, String>> getAgentViewEachTimeStepMap() {
		return agentViewEachTimeStepMap;
	}

	public void setAgentViewEachTimeStepMap(HashMap<String, HashMap<Integer, String>> agentViewEachTimeStepMap) {
		this.agentViewEachTimeStepMap = agentViewEachTimeStepMap;
	}

	public Map<Integer, String> getBestImproveValueMap() {
		return bestImproveValueMap;
	}

	public Map<Integer, Double> getLocalSearchQualityMap() {
		return localSearchQualityMap;
	}

	public double getLocalSearchQualityAt(int iteration) {
		return localSearchQualityMap.get(iteration);
	}

	public void setLocalSearchQuality(int iteration, double quality) {
		this.localSearchQualityMap.put(iteration, quality);
	}

	public Map<Integer, Long> getLocalSearchRuntimeMap() {
		return localSearchRuntimeMap;
	}

	public void setLocalSearchRuntime(int iteration, long runtime) {
		this.localSearchRuntimeMap.put(iteration, runtime);
	}

	public boolean isStop() {
		return stop;
	}

	public void setStop(boolean stop) {
		this.stop = stop;
	}

	public Map<String, String> getValuesToSendInVALUEPhase() {
		return valuesToSendInVALUEPhase;
	}

	public void setValuesToSendInVALUEPhase(HashMap<String, String> valuesToSendInVALUEPhase) {
		this.valuesToSendInVALUEPhase = valuesToSendInVALUEPhase;
	}

	public void addValuesToSendInValuePhase(String agent, String value) {
		this.valuesToSendInVALUEPhase.put(agent, value);
	}

	public Map<Integer, String> getPickedRandomMap() {
		return pickedRandomMap;
	}

	public void setPickedRandomMap(HashMap<Integer, String> pickedRandomMap) {
		this.pickedRandomMap = pickedRandomMap;
	}

	public void addPickedRandomMap(Integer timeStep, String pickedRandomValue) {
		this.pickedRandomMap.put(timeStep, pickedRandomValue);
	}

	public String getPickedRandomAt(Integer timeStep) {
		return this.pickedRandomMap.get(timeStep);
	}

	public long getCurrentUTILstartTime() {
		return currentUTILstartTime;
	}

	public void setCurrentUTILstartTime(long currentUTILstartTime) {
		this.currentUTILstartTime = currentUTILstartTime;
	}

	public String getLastLine() {
		return lastLine;
	}

	public void setLastLine(String lastLine) {
		this.lastLine = lastLine;
	}

	public double[] toArray(List<Double> arrayList) {
		int arrSize = arrayList.size();
		double[] convertedArray = new double[arrSize];
		for (int i = 0; i < arrSize; i++) {
			convertedArray[i] = arrayList.get(i);
		}
		return convertedArray;
	}

	/**
	 * Sample a value from the value at the previous time step and transition
	 * distribution. <br>
	 * If first time step, sample a value for the probability distribution
	 * 
	 * @param currentTimeStep
	 * @return
	 */
	public String simulateOnlineValue(int currentTimeStep) {
		// randomVar is the same as decisionVar string
		String randomVar = agentID;
		double distribution[] = null;

		if (currentTimeStep == 0) {
			distribution = probabilityAtEachTimeStepMap.get(randomVar)[0];	
		}
		// get distribution from transition function, from the previous random values
		else {
			String previousRandValue = pickedRandomMap.get(currentTimeStep - 1);
			distribution = toArray(transitionFunctionMap.get(randomVar).getTransitionOf(previousRandValue));
		}

		double accumualatedProbability = 0;

		for (int i = 0; i < distribution.length; i++) {
			accumualatedProbability += distribution[i];
			if (Double.compare(rdn.nextDouble(), accumualatedProbability) < 0) {
				return selfRandomVariableDomainMap.get(randomVar).get(i);
			}
		}

		return selfRandomVariableDomainMap.get(randomVar).get(0);
	}

	private static double[] multiply(double[] vector, TransitionFunction transFunc) {
		int size = vector.length;
		if (size != transFunc.getSize()) {
			System.err.println("Not a square matrix");
			return null;
		}

		double resultVector[] = new double[size];
		for (int col = 0; col < size; col++) {
			for (int k = 0; k < size; k++) {
				resultVector[col] += vector[k] * transFunc.getProbByIndex(k, col);
			}
		}

		return resultVector;
	}

	public String getOutputFileName() {
		return outputFileName;
	}

	public void setOutputFileName(String outputFileName) {
		this.outputFileName = outputFileName;
	}

	public boolean isAlgorithmIn(PDDcopAlgorithm[] dcopAlgorithmArray) {
		for (PDDcopAlgorithm algorithmInArray : dcopAlgorithmArray) {
			if (pddcop_algorithm == algorithmInArray) {
				return true;
			}
		}

		return false;
	}

	public boolean isDynamic(DynamicType type) {
		return dynamicType == type;
	}

	public DynamicType getDynamicType() {
		return dynamicType;
	}

	public int getHybridTS() {
		return hybridTS;
	}

	public int getHorizon() {
		return horizon;
	}

	public PDDcopAlgorithm getPDDCOP_Algorithm() {
		return pddcop_algorithm;
	}

	public double getSwitchingCost() {
		return switchingCost;
	}

	public int getInstanceID() {
		return instanceID;
	}

	public boolean isFirstInstance() {
		return instanceID == 0;
	}

	public double getHeuristicWeight() {
		return heuristicWeight;
	}

	public Map<String, Double> getAgentHeuristicStringMap() {
		return agentHeuristicStringMap;
	}

	public boolean isRunningPddcopAlgorithm(PDDcopAlgorithm algorithm) {
		return this.pddcop_algorithm == algorithm;
	}

	public String getInputFileName() {
		return inputFileName;
	}

	public List<Table> getRawDecisionTableList() {
		return rawDecisionTableList;
	}

	public List<Table> getRawRandomTableList() {
		return rawRandomTableList;
	}

	public double getDiscountFactor() {
		return discountFactor;
	}

	public HashMap<String, List<String>> getSelfRandomVariableDomainMap() {
		return selfRandomVariableDomainMap;
	}

	public HashMap<String, double[][]> getProbabilityAtEachTimeStepMap() {
		return probabilityAtEachTimeStepMap;
	}

	public List<Table> getDpopDecisionTableList() {
		return dpopDecisionTableList;
	}

	public List<Table> getDpopRandomTableList() {
		return dpopRandomTableList;
	}

	public Map<String, TransitionFunction> getTransitionFunctionMap() {
		return transitionFunctionMap;
	}

	/**
	 * @return the agentCount
	 */
	public int getAgentCount() {
		return agentCount;
	}

	public void updateSolutionQuality(double utility) {
		solutionQuality += utility;
	}

	/**
	 * REVIEWED <br>
	 * Store the solution of DPOP for different algorithms
	 * 
	 * @param value
	 * @param timeStep
	 */
	public void storeDpopSolution(String value, int timeStep) {
		// Store solution at each time step
		if (pddcop_algorithm == PDDcopAlgorithm.C_DCOP) {
			// Set single value at horizon h
			if (dynamicType == DynamicType.INFINITE_HORIZON && timeStep == horizon) {
				chosenValueAtEachTSMap.put(horizon, value);
			}
			// Set a sequence of values
			else {
				String[] values = value.split(",");
				for (int i = 0; i < values.length; i++) {
					chosenValueAtEachTSMap.put(i, values[i]);
				}
			}
		} else {
			chosenValueAtEachTSMap.put(timeStep, value);
		}
	}

	/**
	 * REVIEWED <br>
	 * Compute actual quality for ONLINE algorithms
	 * 
	 * @param timeStep
	 * @return
	 */
	public Map<Integer, Double> computeActualQualityWithoutTime() {
		Map<Integer, Double> solutionQualityMap = new HashMap<>();

		int initTimeStep = pddcop_algorithm == PDDcopAlgorithm.REACT ? -1 : 0;

		for (int ts = initTimeStep; ts <= horizon; ts++) {
			List<Table> tableList = ts <= 0 ? actualDpopTableAcrossTimeStep.get(0)
					: actualDpopTableAcrossTimeStep.get(ts);

			double sumUtility = 0D;
			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();

				for (String variableInList : decVarList) {
					if (variableInList.equals(agentID)) {
						decValueList.add(chosenValueAtEachTSMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(variableInList).get(ts));
					}

				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
			solutionQualityMap.put(ts, sumUtility);
		}

		return solutionQualityMap;
	}

	/**
	 * REVIEWED <br>
	 * From DPOP random table list, return new tables with the corresponding picked
	 * random variables
	 * 
	 * @param timeStep
	 */
	public List<Table> computeActualDpopTableGivenRandomValues(int timeStep) {
		List<Table> tableList = new ArrayList<>();

		// traverse to each random table
		for (Table randTable : getDpopRandomTableList()) {
			List<String> decLabel = randTable.getDecVarLabel();
			// at current time step, create a new table
			// add the tuple with corresponding random values

			Table newTable = new Table(decLabel, AgentPDDCOP.DECISION_TABLE);

			String simulatedRandomValues = getPickedRandomAt(timeStep);

			for (Row row : randTable.getRowList()) {
				if (row.getRandomList().get(0).equals(simulatedRandomValues)) {
					newTable.addRow(new Row(row.getValueList(), row.getUtility()));
				}
			}

			tableList.add(newTable);
		}

		return tableList;
	}
	
	/**
	 * REVIEWED <br>
	 * From DPOP random table list, return new tables with the corresponding picked
	 * random variables
	 * 
	 * @param timeStep
	 */
	public List<Table> computeRLearningDpopTableGivenRandomValues(int timeStep) {
		List<Table> tableList = new ArrayList<>();

		// traverse to each random table
		for (Table randTable : getDpopRandomTableList()) {
			List<String> decLabel = randTable.getDecVarLabel();
			// at current time step, create a new table
			// add the tuple with corresponding random values

			Table newTable = new Table(decLabel, AgentPDDCOP.DECISION_TABLE);

			String simulatedRandomValues = getPickedRandomAt(timeStep);

			for (Row row : randTable.getRowList()) {
				if (row.getRandomList().get(0).equals(simulatedRandomValues)) {
					if (timeStep == 0) {
						// Assume unary constraint
						AugmentedState state = AugmentedState.of(simulatedRandomValues, row.getValueList().get(0));
						double utility = RFunction.get(state);
						newTable.addRow(new Row(row.getValueList(), utility));
//						System.out.println("Agent " + agentID + " for state=" + state + " has R-utility=" + utility);
//						System.out.println("Agent " + agentID + " for state=" + state + " has utility=" + row.getUtility());
					}
					else {
						// Assume unary constraint
						AugmentedState state = AugmentedState.of(simulatedRandomValues, chosenValueAtEachTSMap.get(timeStep - 1), row.getValueList().get(0));
						double utility = RFunction.get(state);
						newTable.addRow(new Row(row.getValueList(), utility));
//						System.out.println("Agent " + agentID + " for state=" + state + " has R-utility=" + utility);
//						System.out.println("Agent " + agentID + " for state=" + state + " has utility=" + row.getUtility());
					}
				}
			}

			tableList.add(newTable);
		}

		return tableList;
	}

	/**
	 * REVIEWED <br>
	 * Compute switching cost for ONLINE algorithms
	 * 
	 * @return
	 */
	public Map<Integer, Double> computeActualSwitchingCost() {
		Map<Integer, Double> switchingCostMap = new HashMap<>();

		if (pddcop_algorithm == PDDcopAlgorithm.REACT) {
			switchingCostMap.put(0,
					switchingCostFunction(chosenValueAtEachTSMap.get(-1), chosenValueAtEachTSMap.get(0)));
		} else {
			switchingCostMap.put(0, 0D);
		}

		for (int ts = 1; ts <= horizon; ts++) {
			switchingCostMap.put(ts,
					switchingCostFunction(chosenValueAtEachTSMap.get(ts - 1), chosenValueAtEachTSMap.get(ts)));
		}
		return switchingCostMap;
	}

	/**
	 * @return the bestImproveUtilityMap
	 */
	public Map<Integer, Double> getBestImproveUtilityMap() {
		return bestImproveUtilityMap;
	}

	/**
	 * Set currentStartTime at the time the function is called
	 */
	public void startSimulatedTiming() {
		currentStartTime = getBean().getCurrentThreadUserTime();
	}

	/**
	 * Update the simulated runtime += currentTime - currentStartTime
	 */
	public void stopStimulatedTiming() {
		simulatedTime += bean.getCurrentThreadUserTime() - currentStartTime;
	}

	public void print() {
		System.out.println();
	}

	public void print(String s, String agentID) {
		if (agentID.equals(this.agentID)) {
			print(s);
		}
	}

	public void print(String s) {
//    if (agentID.equals("8")) {
		System.out.println("Agent " + agentID + " " + s);
//    }
	}

	public boolean isRunningPDDCOPLocalSearch() {
		return pddcop_algorithm == PDDcopAlgorithm.LS_RAND || pddcop_algorithm == PDDcopAlgorithm.LS_SDPOP;
	}

	/**
	 * True by default, all agents are assumed to recompute everything
	 * 
	 * @return
	 */
	public boolean isRecomputingDPOP_UTIL() {
		return recomputingDPOP_UTIL;
	}

	/**
	 * Need only set to false
	 * 
	 * @param recomputingDPOP_UTIL
	 */
	public void setRecomputingDPOP_UTILToFalse() {
		this.recomputingDPOP_UTIL = false;
	}

	public Table getStoredReuseTable() {
		return storedReuseTable;
	}

	public void setStoredReuseTable(Table storedReuseTable) {
		this.storedReuseTable = storedReuseTable;
	}

	public Set<String> getReuseChildUTIL() {
		return reuseChildUTIL;
	}

	public void setReuseChildUTIL(Set<String> reuseChildUTIL) {
		this.reuseChildUTIL = reuseChildUTIL;
	}

	public Map<Integer, List<Table>> getActualDpopTableAcrossTimeStep() {
		return actualDpopTableAcrossTimeStep;
	}

	public List<Table> getActualDpopTableAcrossTimeStep(int timeStep) {
		return actualDpopTableAcrossTimeStep.get(timeStep);
	}

	public void setActualDpopTableAcrossTimeStep(Map<Integer, List<Table>> actualDpopTableAcrossTimeStep) {
		this.actualDpopTableAcrossTimeStep = actualDpopTableAcrossTimeStep;
	}

	public Map<Integer, List<Table>> getActualTableAcrossTimeStep() {
		return actualTableAcrossTimeStep;
	}

	public List<Table> getActualTableAcrossTimeStep(int timeStep) {
		return actualTableAcrossTimeStep.get(timeStep);
	}

	public void setActualTableAcrossTimeStep(Map<Integer, List<Table>> actualTableAcrossTimeStep) {
		this.actualTableAcrossTimeStep = actualTableAcrossTimeStep;
	}

	public long getOnlineSolvingTime(int timeStep) {
		return onlineSolvingTime.get(timeStep);
	}

	public void setOnlineSolvingTime(int timeStep, long onlineSolvingTimes) {
		onlineSolvingTime.put(timeStep, onlineSolvingTimes);
	}

	public Random getRandom() {
		return rdn;
	}

	public String getLocalSearchOutputFileName() {
		return localSearchOutputFileName;
	}

	public Map<Integer, Double> getEffectiveQualityMap() {
		return effectiveQualityMap;
	}

	public Map<Integer, Double> getEffectiveSwitchingCostMap() {
		return effectiveSwitchingCostMap;
	}

	public Map<Integer, Long> getEffectiveSolvingTimeMap() {
		return effectiveSolvingTimeMap;
	}

	public long getFinalRuntime() {
		return finalRuntime;
	}

	public void setFinalRuntime(long finalRuntime) {
		this.finalRuntime = finalRuntime;
	}

	public String getCDPOP_value() {
		return CDPOP_value;
	}

	public void setCDPOP_value(String cDPOP_value) {
		CDPOP_value = cDPOP_value;
	}

	/**
	 * @return the randomSeed
	 */
	public long getRandomSeed() {
		return randomSeed;
	}

	/**
	 * @param randomSeed the randomSeed to set
	 */
	public void setRandomSeed(long randomSeed) {
		this.randomSeed = randomSeed;
	}

	public double computeMGMLocalUtility(String regionValue, int timeStep) {
		List<Table> tableList = new ArrayList<>(mgmTableList);

		double utility = 0;
		for (Table constraintTable : tableList) {
			List<String> decValueList = new ArrayList<>();
			// get value from agentView
			// add value to decValue -> getUtility
			for (String regionInScope : constraintTable.getDecVarLabel()) {
				if (regionInScope.equals(agentID)) {
					decValueList.add(regionValue);
				} else {
					decValueList.add(agentViewEachTimeStepMap.get(regionInScope).get(timeStep));
				}
			}

			utility += constraintTable.getUtilityGivenDecValueList(decValueList);
		}

		return utility;
	}

	public List<Table> getMgmTableList() {
		return mgmTableList;
	}

	public void setMgmTableList(List<Table> mgmTableList) {
		this.mgmTableList = mgmTableList;
	}

	/**
	 * @return the dcop_algorithm
	 */
	public DcopAlgorithm getDcop_algorithm() {
		return dcop_algorithm;
	}

	/**
	 * @param dcop_algorithm the dcop_algorithm to set
	 */
	public void setDcop_algorithm(DcopAlgorithm dcop_algorithm) {
		this.dcop_algorithm = dcop_algorithm;
	}

	public Map<Integer, Double> getMGMQualityMap() {
		return MGMQualityMap;
	}

	public Map<Integer, Long> getMGMRuntimeMap() {
		return MGMRuntimeMap;
	}

	public Map<Integer, Long> getMGMdifferenceRuntimeMap() {
		return MGMdifferenceRuntimeMap;
	}

	public void setMGMdifferenceRuntimeMap(Map<Integer, Long> mGMdifferenceRuntimeMap) {
		MGMdifferenceRuntimeMap = mGMdifferenceRuntimeMap;
	}

	public void setMGMQuality(int localTimeStep, double quality) {
		MGMQualityMap.put(localTimeStep, quality);
	}

	public void setMGMRuntime(int localTimeStep, long runtime) {
		MGMRuntimeMap.put(localTimeStep, runtime);
	}

	/**
	 * @return the total utilities of constraints between self agent and
	 *         parents/pseudo-parents
	 */
	public double getLocalUtilitiesForUTIL(String regionValue, int timeStep) {
		List<Table> tableList = new ArrayList<>(mgmTableList);

		double utility = 0;
		for (Table constraintTable : tableList) {
			// Ignore the table if contains child/pseudochild
			List<String> tempLabel = new ArrayList<>(constraintTable.getDecVarLabel());
			tempLabel.remove(agentID);
			tempLabel.removeAll(parentAndPseudoStrList);
			if (!tempLabel.isEmpty()) {
				continue;
			}

			List<String> decValueList = new ArrayList<>();
			// get value from agentView
			// add value to decValue -> getUtility
			for (String regionInScope : constraintTable.getDecVarLabel()) {
				if (regionInScope.equals(agentID)) {
					decValueList.add(regionValue);
				} else {
					decValueList.add(agentViewEachTimeStepMap.get(regionInScope).get(timeStep));
				}
			}

			utility += constraintTable.getUtilityGivenDecValueList(decValueList);
		}

		return utility;
	}

//	public int getOnlineRun() {
//		return onlineRun;
//	}
//
//	public void setOnlineRun(int onlineRun) {
//		this.onlineRun = onlineRun;
//	}

	public void setOnlineOutputFileName(String onlineOutputFileName) {
	}

	/**
	 * @return the onlineOutputFileName
	 */
	public String getOnlineOutputFileName() {
		return onlineOutputFileName;
	}

	public List<Table> getDpopBoundRandomTableList() {
		return null;
	}

	public double getAverageRewardR() {
		return averageRewardR;
	}

	public void setAverageRewardR(double averageRewardR) {
		this.averageRewardR = averageRewardR;
	}

	public boolean isSolvingForCurrentState() {
		return isSolvingForCurrentState;
	}

	public void setSolvingForCurrentState(boolean isSolvingForCurrentState) {
		this.isSolvingForCurrentState = isSolvingForCurrentState;
	}

	public String getSolutionForCurrentState() {
		return solutionForCurrentState;
	}

	public void setSolutionForCurrentState(String solutionForCurrentState) {
		this.solutionForCurrentState = solutionForCurrentState;
	}

	public String getSolutionForNextState() {
		return solutionForNextState;
	}

	public void setSolutionForNextState(String solutionForNextState) {
		this.solutionForNextState = solutionForNextState;
	}

	public double getAlpha_r() {
		return alpha_r;
	}

	public void setAlpha_r(double alpha_r) {
		this.alpha_r = alpha_r;
	}

	public double getBeta_r() {
		return beta_r;
	}

	public void setBeta_r(double beta_r) {
		this.beta_r = beta_r;
	}
	
	public Map<AugmentedState, Double> getRFunction() {
		return RFunction;
	}

	public void setRFunction(Map<AugmentedState, Double> rFunction) {
		RFunction = rFunction;
	}

	public boolean isApplyingRLearning() {
		return isApplyingRLearning;
	}
	
	public void switchApplyingRLearning() {
		this.isApplyingRLearning = !isApplyingRLearning;
	}

	public void setApplyingRLearning(boolean isApplyingRLearning) {
		this.isApplyingRLearning = isApplyingRLearning;
	}

	public HashMap<String, Interval> getDecisionVariableIntervalMap() {
		return decisionVariableIntervalMap;
	}

	public void setDecisionVariableIntervalMap(HashMap<String, Interval> decisionVariableIntervalMap) {
		this.decisionVariableIntervalMap = decisionVariableIntervalMap;
	}

	public HashMap<String, Interval> getSelfRandomVariableIntervalMap() {
		return selfRandomVariableIntervalMap;
	}

	public void setSelfRandomVariableIntervalMap(HashMap<String, Interval> selfRandomVariableIntervalMap) {
		this.selfRandomVariableIntervalMap = selfRandomVariableIntervalMap;
	}

  public TransitionFamilyDistribution getTransitionDistribution() {
    return transitionDistribution;
  }

  public void setTransitionDistribution(TransitionFamilyDistribution transitionDistribution) {
    this.transitionDistribution = transitionDistribution;
  }

  public BetaDistribution getInitialDistribution() {
    return initialDistribution;
  }

  public void setInitialDistribution(BetaDistribution initialDistribution) {
    this.initialDistribution = initialDistribution;
  }
}
