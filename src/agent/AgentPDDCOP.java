package agent;

import static java.lang.System.out;
import static agent.DcopConstants.RANDOM_PREFIX;
import static agent.DcopConstants.DEFAULT_BETA_SAMPLING_SEED;
import static agent.DcopConstants.SAMPLING_ITERATION;
import static agent.DcopConstants.INPUT_FOLDER;
import static agent.DcopConstants.MAX_ITERATION;
import static agent.DcopConstants.MARKOV_CONVERGENCE_TIME_STEP;
import static agent.DcopConstants.NOT_TO_OPTIMIZE_INTERVAL;
import static agent.DcopConstants.DECISION_TABLE;
import static agent.DcopConstants.RANDOM_TABLE;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.zip.GZIPOutputStream;
import java.util.Random;

import com.google.common.collect.Sets;

import agent.DcopConstants.DcopAlgorithm;
import agent.DcopConstants.DcopType;
import agent.DcopConstants.DynamicType;
import agent.DcopConstants.PDDcopAlgorithm;
import agent.DcopConstants.SwitchingType;

import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.random.Well19937c;

import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import behavior.SEND_RECEIVE_FINAL_UTIL;
import behavior.SEND_RECEIVE_FINAL_UTIL_CONTINUOUS;
import behavior.AGENT_TERMINATE;
import behavior.CONTINUOUS_DSA;
import behavior.DPOP_UTIL;
import behavior.DPOP_VALUE;
import behavior.GD_RAND_PICK_VALUE;
import behavior.GD_RECEIVE_SEND_LS_UTIL;
import behavior.GD_SEND_RECEIVE_IMPROVE;
import behavior.GD_SEND_RECEIVE_VALUE;
import behavior.INIT_PROPAGATE_DPOP_VALUE;
import behavior.INIT_RECEIVE_DPOP_VALUE;
import behavior.INIT_RECEIVE_SEND_LS_UTIL;
import behavior.LS_RECEIVE_SEND_LS_UTIL;
import behavior.MESSAGE_TYPE;
import behavior.MGM_RAND_PICK_VALUE;
import behavior.MGM_SEND_RECEIVE_IMPROVE;
import behavior.MGM_SEND_RECEIVE_UTIL;
import behavior.MGM_SEND_RECEIVE_VALUE;
import behavior.PSEUDOTREE_GENERATION;
import behavior.LS_RAND_PICK_VALUE;
import behavior.LS_RECEIVE_IMPROVE;
import behavior.SEND_RECEIVE_FINAL_VALUE;
import behavior.SEND_RECEIVE_FINAL_VALUE_CONTINUOUS;
import function.Interval;
import function.multivariate.MultivariateQuadFunction;
import function.multivariate.PiecewiseMultivariateQuadFunction;
import behavior.R_LEARNING_UPDATE;
import behavior.LS_RECEIVE_VALUE;
import behavior.SEARCH_NEIGHBORS;
import behavior.LS_SEND_IMPROVE;
import behavior.MAXSUM_FUNCTION_TO_VARIABLE;
import behavior.MAXSUM_VARIABLE_TO_FUNCTION;
import table.AugmentedState;
import table.RowString;
import table.TableDouble;
import table.TableString;
import transition.BetaDistribution;
import transition.TransitionFamilyDistribution;
import transition.TransitionFunction;
import jade.core.AID;
import jade.core.Agent;
import jade.core.behaviours.SequentialBehaviour;
import jade.domain.DFService;
import jade.domain.FIPAException;
import jade.domain.FIPAAgentManagement.DFAgentDescription;
import jade.domain.FIPAAgentManagement.ServiceDescription;
import jade.lang.acl.ACLMessage;
import maxsum.MaxSumMessage;

/* Each agent is a node in the graph
 * The graph is presented as pseudo-tree
 * Pseudo-tree is generated by Distributed DFS
 * 
 * Each Agent has a "root" flag to indicate root or not
 * Each Agent has a local name which is an ID number and is assigned by constructor.
 * Based on the ID number, each agent has a fixed number neighbors, which is instantiated
 * by the constructor
 * 
 * ****PROCESS OF FINDING AID NEIGHBORS
 * Each Agent has a list of neighbors, and register his neighbors ID number to DF
 * Each Agent find his neighbors' AIDs by searching DF which agents register the Agent's ID numbers as
 * a neighbor. The add to his list of AID neighbors.
 * 
 * The process of finding AIDs only stops when the number of recognized AID is the number of his neighbors
 * 
 * ****PROCESS OF GENERATING PSEUDOTREE
 * Each agent always listens to the first messages, while trying to finish the searching process
 * After finishing the searching process, he begins to process the messages and send the message to his
 * neighbors.
 * 
 * Agent root start sending messages when finish searching agents.
 * 
 * Each agents will print out his parent, his children, his pseudo-parents, his pseudo-children
 * 
 * ****PROCESS OF DPOP
 * DPOP starts when the PSEUDOTREE PROCESS FINISHED
 */
/**
 * @author khoihd
 *
 */
public class AgentPDDCOP extends Agent {

	private static final long serialVersionUID = 2919994686894853596L;
	
  public final SwitchingType SWITCHING_TYPE = SwitchingType.QUADRATIC;

	/*
	 * DCOP parameters To be read from arguments
	 */
	private String agentID;
	
	private PDDcopAlgorithm pddcop_algorithm;
	private DcopAlgorithm dcop_algorithm;
	private DcopType dcopType;
	private int horizon;
	private double switchingCost;
	private DynamicType dynamicType;
	private double discountFactor;
	private String inputFileName;
	private double heuristicWeight;
	
	// mapping <neighbor, function<>
	private Map<String, PiecewiseMultivariateQuadFunction> neighborFunctionMap = new HashMap<>();

  private PiecewiseMultivariateQuadFunction agentViewFunction;
  
  // Assume binary and unary functions
	private Map<String, PiecewiseMultivariateQuadFunction> functionWithPParentMap = new HashMap<>();
	private Map<Integer, PiecewiseMultivariateQuadFunction> expectedFunctionMap = new HashMap<>();
	
	// for Hybrid Max-Sum
	private Map<String, PiecewiseMultivariateQuadFunction> MSFunctionOwnedByMeMap = new HashMap<>();
	
	private Map<String, PiecewiseMultivariateQuadFunction> currrentMSFunctionOwnedByMeMap = new HashMap<>();

	/*
	 * Read from input file
	 */
	private int instanceID;
	/*
	 * Computed from the arguments
	 */
	private String outputFileName;
	private String localSearchOutputFileName;
	private String onlineOutputFileName;
	private int hybridTS;

	private boolean isRoot = false;
	private boolean isLeaf = false;

	private AID parentAID;
	private Set<AID> childrenAIDSet = new HashSet<>();
	private Set<AID> neighborAIDSet = new HashSet<>();
	private Set<AID> pseudoParentAIDSet = new HashSet<>();
	private Set<AID> pseudoChildrenAIDSet = new HashSet<>();
	private List<String> parentAndPseudoStrList = new ArrayList<>();
	private Set<String> neighborStrSet = new HashSet<>();

	private List<TableString> dpopDecisionTableList = new ArrayList<>();
	private List<TableString> dpopRandomTableList = new ArrayList<>();
	@SuppressWarnings("unused")
	private List<TableString> dpopBoundRandomTableList = new ArrayList<>();
	private SortedMap<String, List<String>> boundDpopRandomDomains = new TreeMap<>();

	private List<TableString> mgmTableList = new ArrayList<>();

	private List<TableString> rawDecisionTableList = new ArrayList<>();
	private List<TableString> rawRandomTableList = new ArrayList<>();

	private List<String> decisionVariableList = new ArrayList<>();
//	private List<String> selfVariableList = new ArrayList<>();
	private Map<String, List<String>> decisionVariableDomainMap = new HashMap<>();
	private Map<String, Interval> decisionVariableIntervalMap = new HashMap<>();
	private Map<String, List<String>> selfRandomVariableDomainMap = new HashMap<>();
	private Map<String, Interval> randomVariableIntervalMap = new HashMap<>();
	// map TS -> constraint table list (if local_search)
	// map TS -> 1 collapsed table list (if collapsed dpop)
	private Map<Integer, List<TableString>> discountedExpectedTableEachTSMap = new HashMap<>();
	private Map<String, double[][]> probabilityAtEachTimeStepMap = new HashMap<>();

	// VALUE phase
	private Map<String, String> valuesToSendInVALUEPhase = new HashMap<>();
	private Map<String, Double> doubleValuesToSendInVALUEPhase = new HashMap<>();

	// used for LOCAL SEARCH
	private Map<Integer, String> chosenValueAtEachTSMap = new HashMap<>();
	// List<Double> utilityAtEachTSList;
	// agent -> <values0, values1, ..., values_n>
	private Map<String, HashMap<Integer, String>> agentViewEachTimeStepMap = new HashMap<>();
	private List<Double> currentGlobalUtilityList = new ArrayList<>();
	private Map<Integer, String> bestImproveValueMap = new HashMap<>();
	private Map<Integer, Double> bestImproveUtilityMap = new HashMap<>();

	/**
	 * Object since it could be null
	 */
//	private double currentLocalSearchSolutionQuality;
	private double solutionQuality;
	private Map<Integer, Double> effectiveQualityMap = new HashMap<>();
	private Map<Integer, Double> effectiveSwitchingCostMap = new HashMap<>();
	private Map<Integer, Long> effectiveSolvingTimeMap = new HashMap<>();

//	private Map<String, List<Double>> initProabilityMap = new HashMap<>();
	/**
	 * Random variable -> TransitionFunction
	 */
	private Map<String, TransitionFunction> transitionFunctionMap = new HashMap<>();
	private TableString agentViewTable;
	private TableDouble agentViewTableDouble;
	private Map<Integer, String> pickedRandomMap = new HashMap<>();

	private long currentUTILstartTime;

	// simulated time
	private ThreadMXBean bean;
	private long simulatedTime = 0;
	private long currentStartTime;
	private static long delayMessageTime = 0; // in milliseconds

	// for reuse information
	private Map<String, Double> agentHeuristicStringMap = new HashMap<>();
	private boolean notVisited = true;

	// List<String> neighborWithRandList;

	// Mapping from iteration to quality/runtime. Store the quality of the best LS
	// solution.
	private Map<Integer, Double> localSearchQualityMap = new HashMap<>();
	private Map<Integer, Long> localSearchRuntimeMap = new HashMap<>();

	private Map<Integer, Double> MGMQualityMap = new HashMap<>();
	private Map<Integer, Long> MGMRuntimeMap = new HashMap<>();

//	private double lastMGMQuality = 
//	private long lastMGMRuntime = 0L;
	
	 // for reuse information
  private Map<AID, Integer> constraintInfoMap = new HashMap<>();

	// Mapping from horizon to the difference in runtime of when the solution
	// converges to the last time step
	private Map<Integer, Long> MGMdifferenceRuntimeMap = new HashMap<>();
	
	// R_Learning
//	private Map<Integer, String> randomRealizationForLearning = new HashMap<>();

	private Map<AugmentedState, Double> RFunction = new HashMap<>();

	private double averageRewardR = 0;
	private boolean isSolvingForCurrentState = true;
	private String solutionForCurrentState;
	private String solutionForNextState;
	private double alpha_r = 0.05;
	private double beta_r = 0.5;
	private int rLearningIteration; // The number of iterations used for R-LEARNING
	private boolean isApplyingRLearning = true;
	

	private boolean stop = false;
	private String lastLine = "";
	private int agentCount;
	private int randomCount;
	// Root is the agent with most neighbors
	private String rootAgent;

	private boolean recomputingDPOP_UTIL = true; // default, all agents have to recompute everything
	private TableString storedReuseTable;
	private Set<String> reuseChildUTIL = new HashSet<>();
	private Random rdn = new Random();
	private Map<Integer, List<TableString>> actualDpopTableAcrossTimeStep = new HashMap<>();
	private Map<Integer, List<TableString>> actualTableAcrossTimeStep = new HashMap<>();

	private Map<Integer, Long> onlineSolvingTime = new HashMap<>();
	private long finalRuntime;

	private String CDPOP_value;
	private long randomSeed;

	public int decisionDomain;
	public int randomDomain;
	
	private Map<String, BetaDistribution> initialDistributionMap = new HashMap<>();
	private Map<String, TransitionFamilyDistribution> transitionDistributionFamilyMap = new HashMap<>();
  private Map<String, Set<String>> neighborSetMap = new HashMap<>();
  private Map<Integer, Double> meanAtEveryTimeStep = new HashMap<>(); // Assume that each agent has at most one random variable
  
  private Map<Integer, PiecewiseMultivariateQuadFunction> dpopFunctionEachTimeStepMap = new HashMap<>();
  private Map<Integer, List<TableString>> dpopTableEachTimeStepMap = new HashMap<>();

	public static String OUTPUT_FOLDER;
	
  private int gradientIteration;
  private int numberOfPoints;

  private Map<Integer, Set<Double>> currentDiscreteValuesMap = new HashMap<>();
  
  private int lsIteration = 0;
  
  private Map<Integer, Double> chosenDoubleValueAtEachTSMap = new HashMap<>();
  
  private final boolean isApprox = true; // Used in APPROX_DPOP
  private final int numberOfApproxAgents = 0; // Used in APPROX_DPOP
  
  private Set<AID> functionOwnedByMe = new HashSet<>(); // Set of neighbors where I own the constraint with
  private Set<AID> functionOwnedByOther = new HashSet<>(); // Set of neighbors where they own the constraint
  private Map<AID, MaxSumMessage> received_FUNCTION_TO_VARIABLE = new HashMap<>();
  private Map<AID, MaxSumMessage> received_VARIABLE_TO_FUNCTION = new HashMap<>();
  private Map<AID, MaxSumMessage> stored_FUNCTION_TO_VARIABLE = new HashMap<>();
  private Map<AID, MaxSumMessage> stored_VARIABLE_TO_FUNCTION = new HashMap<>();
  private Map<String, HashMap<Integer, Double>> agentViewDoubleEachTimeStepMap = new HashMap<>();
  
  private Map<Integer, Double> localSearchMaximumGain = new HashMap<>();
  private Map<Integer, Double> localSearchArgmax = new HashMap<>();

	public AgentPDDCOP() {
	}

	private void setOutputFileName() {
		StringBuffer sb = new StringBuffer();
		OUTPUT_FOLDER = "output_files/" + dynamicType + "/";
		try {
			Files.createDirectories(Paths.get(OUTPUT_FOLDER));
		} catch (IOException e) {
			e.printStackTrace();
		}

		sb.append("x=" + agentCount);
		sb.append("_y=" + randomCount);
		sb.append("_dx=" + decisionDomain);
		sb.append("_dy=" + randomDomain);
		sb.append("_sw=" + (int) switchingCost);
		sb.append("_h=" + horizon);
		sb.append("_discountFactor=" + discountFactor);
		sb.append("_heuristicWeight=" + heuristicWeight);
		sb.append("_" + pddcop_algorithm + "_" + dcop_algorithm + "_" + dynamicType);
		if (pddcop_algorithm == PDDcopAlgorithm.R_LEARNING) {
			sb.append("_rLearningIteration=" + rLearningIteration);
			sb.append("_alpha=" + alpha_r);
			sb.append("_beta=" + beta_r);
		}
		sb.append(".txt");

		outputFileName = OUTPUT_FOLDER + sb.toString();
		if (isRunningPDDCOPLocalSearch() || dynamicType == DynamicType.ONLINE || dynamicType == DynamicType.STATIONARY) {
			String localSearchFolder = OUTPUT_FOLDER + "/" + pddcop_algorithm + "_" + dcop_algorithm + "/";
			try {
				Files.createDirectories(Paths.get(localSearchFolder));
			} catch (IOException e) {
				e.printStackTrace();
			}

			sb.insert(0, "instanceID=" + instanceID + "_");
			localSearchOutputFileName = localSearchFolder + sb.toString();
			onlineOutputFileName = localSearchOutputFileName; 
		}
	}

	public void readArguments() {
		Object[] args = getArguments();
		out.println(Arrays.deepToString(args));

		// parameters for running experiments
		pddcop_algorithm = PDDcopAlgorithm.valueOf((String) args[0]);
		dcop_algorithm = DcopAlgorithm.valueOf((String) args[1]);
		inputFileName = (String) args[2]; // random_x14_y123/instance_10_x14_y123.dzn
		horizon = Integer.valueOf((String) args[3]);
		switchingCost = Integer.valueOf((String) args[4]);
		discountFactor = Double.valueOf((String) args[5]);
		dynamicType = DynamicType.valueOf((String) args[6]);
		heuristicWeight = Double.valueOf((String) args[7]);
		rLearningIteration = Integer.valueOf((String) args[8]); // The number of iterations used for R-LEARNING
    gradientIteration = Integer.valueOf((String) args[9]);
    numberOfPoints = Integer.valueOf((String) args[10]);
		dcopType = DcopType.valueOf((String) args[11]);

		String a[] = inputFileName.substring(inputFileName.indexOf("/") + 1).replaceAll("instance_", "")
				.replaceAll(".dzn", "").split("_");

		instanceID = Integer.valueOf(a[0]);

		agentCount = Integer.valueOf(a[1].replace("x", ""));
		randomCount = Integer.valueOf(a[2].replace("y", ""));
		decisionDomain = Integer.valueOf(a[3].replace("dx", ""));
		randomDomain = Integer.valueOf(a[4].replace("dy", ""));

		agentID = getLocalName().replace("x", "");

		for (int timeStep = 0; timeStep <= horizon; timeStep++) {
			discountedExpectedTableEachTSMap.put(timeStep, new ArrayList<TableString>());
		}

		// Different seed values for combination of (instanceID, agentID)
		randomSeed = (instanceID + 1) * Integer.valueOf(agentID) * horizon;
		rdn.setSeed(randomSeed);
	}

	public int getrLearningIteration() {
		return rLearningIteration;
	}

	public void setrLearningIteration(int rLearningIteration) {
		this.rLearningIteration = rLearningIteration;
	}

	protected void setup() {
		readArguments();
		
		if (dcopType == DcopType.DISCRETE) {
			parseInputFileDiscrete(INPUT_FOLDER + "/" + inputFileName);
		} else {
			parseInputFileContinuous(INPUT_FOLDER + "/" + inputFileName);
		}

		// Set root
		isRoot = getLocalName().equals(rootAgent);
		
		setOutputFileName();

		if (isRoot) {
			print("AgentID = " + agentID);
			print("PDDCOP Algorithm = " + pddcop_algorithm);
			print("DCOP Algorithm = " + dcop_algorithm);
			print("Input file name = " + inputFileName);
			print("InstanceID = " + instanceID);
			print("Switching cost = " + switchingCost);
			print("Discount factor = " + discountFactor);
			print("Horizon = " + horizon);
			print("Heuristic weight = " + heuristicWeight);
			print("Max iteration=" + MAX_ITERATION);
		}

		registerWithDF();
		bean = ManagementFactory.getThreadMXBean();
		bean.setThreadContentionMonitoringEnabled(true);
		
		if (isContinuous()) {
		  print("decisionVariableIntervalMap=" + decisionVariableIntervalMap);
		  print("randomVariableIntervalMap=" + randomVariableIntervalMap);
		  print("functionMap=" + neighborFunctionMap);
		  print("neighborSetMap=" + neighborSetMap);
		  print("initialDistributionMap=" + initialDistributionMap);
		  print("transitionDistributionFamily=" + transitionDistributionFamilyMap);
		}

		SequentialBehaviour mainSequentialBehaviourList = isDiscrete() ? computeBehaviorDiscrete() : computeBehaviorContinuous();
		addBehaviour(mainSequentialBehaviourList);
	}
	
  /**
   *  Naive sampling and use Welford's online algorithm to compute running mean
   */
  private void samplingAndComputeMean() {
    String randVar = getSelfRanomVariable();
    
    // Do nothing if not having random variable
    if (!randomVariableIntervalMap.containsKey(randVar)) {
      return ;
    }
    
    for (int samplingIteration = 1; samplingIteration <= SAMPLING_ITERATION; samplingIteration++) {
      BetaDistribution currentDistribution = initialDistributionMap.get(randVar);

      for (int timeStep = 0; timeStep <= horizon; timeStep++) {
        double currentMean = meanAtEveryTimeStep.getOrDefault(timeStep, 0D);
        double sample = currentDistribution.sample();
        
        // ((n-1) * m_{n-1} + x_n) / n
        double updatedMean = ((samplingIteration - 1) * currentMean + sample) / samplingIteration;
        meanAtEveryTimeStep.put(timeStep, updatedMean);

        // Compute the Beta distribution for the next time step
        currentDistribution = transitionDistributionFamilyMap.get(randVar).computeBetaDistribution(sample);
      }
    }
  }
	
	/**
	 * THIS METHOD HAS BEEN REVIEWED
	 * @return
	 */
	private SequentialBehaviour computeBehaviorContinuous() {
    // Simulate the random variable values and compute the mean
	  // This step is necessary for *all* algorithms
    samplingAndComputeMean();
        
    // Discretize the domains for every time step
    for (int timeStep = 0; timeStep <= horizon; timeStep ++) {
      currentDiscreteValuesMap.put(timeStep, decisionVariableIntervalMap.get(getLocalName()).getMidPoints(numberOfPoints));
    }
	  
	  SequentialBehaviour mainSequentialBehaviourList = new SequentialBehaviour();
	  
	  mainSequentialBehaviourList.addSubBehaviour(new SEARCH_NEIGHBORS(this));
	  mainSequentialBehaviourList.addSubBehaviour(new PSEUDOTREE_GENERATION(this));
    
    if (pddcop_algorithm == PDDcopAlgorithm.FORWARD || pddcop_algorithm == PDDcopAlgorithm.GRADIENT) {
      for (int timeStep = 0; timeStep <= horizon; timeStep++) {
        if (isRuningDPOPFamily()) {
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, timeStep));
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, timeStep));
        }
        else if (dcop_algorithm == DcopAlgorithm.CONTINUOUS_DSA) {
          for (int iteration = 0; iteration <= MAX_ITERATION; iteration++) {          
            mainSequentialBehaviourList.addSubBehaviour(new CONTINUOUS_DSA(this, timeStep, iteration));
          }
        }        
        else if (isRunningMaxsum()) {
          for (int iteration = 0; iteration <= MAX_ITERATION; iteration++) {          
            mainSequentialBehaviourList.addSubBehaviour(new MAXSUM_VARIABLE_TO_FUNCTION(this, timeStep, iteration));
            mainSequentialBehaviourList.addSubBehaviour(new MAXSUM_FUNCTION_TO_VARIABLE(this, timeStep, iteration));
          }
        }
        else if (dcop_algorithm == DcopAlgorithm.RANDOMIZE) {
          mainSequentialBehaviourList.addSubBehaviour(new GD_RAND_PICK_VALUE(this, timeStep));
        }
      }
    }
    else if (pddcop_algorithm == PDDcopAlgorithm.BACKWARD) {
      for (int timeStep = horizon; timeStep >= 0; timeStep--) {
        if (isRunningDPOPFamily()) {
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, timeStep));
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, timeStep));
        } 
        else if (dcop_algorithm == DcopAlgorithm.CONTINUOUS_DSA) {
          for (int iteration = 0; iteration <= MAX_ITERATION; iteration++) {          
            mainSequentialBehaviourList.addSubBehaviour(new CONTINUOUS_DSA(this, timeStep, iteration));
          }
        }        
        else if (isRunningMaxsum()) {
          for (int iteration = 0; iteration <= MAX_ITERATION; iteration++) {          
            mainSequentialBehaviourList.addSubBehaviour(new MAXSUM_VARIABLE_TO_FUNCTION(this, timeStep, iteration));
            mainSequentialBehaviourList.addSubBehaviour(new MAXSUM_FUNCTION_TO_VARIABLE(this, timeStep, iteration));
          }
        }
      }
    }
    
    // Additional behaviors for GRADIENT to search for better solution 
    if (pddcop_algorithm == PDDcopAlgorithm.GRADIENT) {
      int initialIteration = -1;
      mainSequentialBehaviourList.addSubBehaviour(new GD_SEND_RECEIVE_VALUE(this, initialIteration));
      mainSequentialBehaviourList.addSubBehaviour(new GD_RECEIVE_SEND_LS_UTIL(this, initialIteration));
      
      for (int iteration = 0; iteration < MAX_ITERATION; iteration++) {
        mainSequentialBehaviourList.addSubBehaviour(new GD_SEND_RECEIVE_IMPROVE(this, iteration));
        // TODO: Should agents send the list of updated values
        // Not necessary if agents can change value on their own and there are not two neighbors changing values at the same time
        mainSequentialBehaviourList.addSubBehaviour(new GD_SEND_RECEIVE_VALUE(this, initialIteration));
        mainSequentialBehaviourList.addSubBehaviour(new GD_RECEIVE_SEND_LS_UTIL(this, iteration));
      }
    }
    
    // All algorithms are evaluated by the same FINAL VALUE and UTIL behaviors
    mainSequentialBehaviourList.addSubBehaviour(new SEND_RECEIVE_FINAL_VALUE_CONTINUOUS(this));
    mainSequentialBehaviourList.addSubBehaviour(new SEND_RECEIVE_FINAL_UTIL_CONTINUOUS(this));
    
    mainSequentialBehaviourList.addSubBehaviour(new AGENT_TERMINATE(this));

	  return mainSequentialBehaviourList;
	}

  private SequentialBehaviour computeBehaviorDiscrete() {
   int theLastTimeStep = simulateActualValueAndComputeDistribution();
    
    // Simulate random variables for R_LEARNING in Discrete PD-DCOPs
    if (pddcop_algorithm == PDDcopAlgorithm.R_LEARNING && isDiscrete()) {
      simulateActualValueForRLearning();
      
      // Initialize R functions
      for (String previous : decisionVariableDomainMap.get(agentID)) {
        for (String current : decisionVariableDomainMap.get(agentID)) {
          for (String random : selfRandomVariableDomainMap.get(agentID)) {
            AugmentedState state = AugmentedState.of(random, previous, current);
            RFunction.put(state, 0D);
            
            // Previous = null for the case of horizon = 0
            AugmentedState state_null_prev = AugmentedState.of(random, current);
            RFunction.put(state_null_prev, 0D);
          }
        } 
      }
    }
    
    print("pickedRandomMap=" + pickedRandomMap);
    print("probabilityAtEachTimeStepMap=");
    for (Entry<String, double[][]> entry : probabilityAtEachTimeStepMap.entrySet()) {
      print(entry.getKey() + "=" + Arrays.deepToString(entry.getValue()));
    }
	  
	  SequentialBehaviour mainSequentialBehaviourList = new SequentialBehaviour();
    // Done reviewing these two behaviors
    mainSequentialBehaviourList.addSubBehaviour(new SEARCH_NEIGHBORS(this));
    mainSequentialBehaviourList.addSubBehaviour(new PSEUDOTREE_GENERATION(this));

    // Solve for the last time step for INFINITE
    if (dynamicType == DynamicType.INFINITE_HORIZON) {
      if (dcop_algorithm == DcopAlgorithm.DPOP && pddcop_algorithm != PDDcopAlgorithm.LS_RAND) {
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, horizon));
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, horizon));
      } else if (dcop_algorithm == DcopAlgorithm.MGM) {
        mainSequentialBehaviourList.addSubBehaviour(new MGM_RAND_PICK_VALUE(this, horizon));
        for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
          mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_VALUE(this, horizon));
          mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_IMPROVE(this, horizon));
          mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_UTIL(this, horizon, localTS));
        }
      }
    }

    // Combine DCOPs from 0 -> theLastTimeStep
    // Take into account the switching cost to the solution at horizon h if there is any
    if (pddcop_algorithm == PDDcopAlgorithm.C_DCOP) {
      if (dcop_algorithm == DcopAlgorithm.DPOP) {
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, theLastTimeStep));
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, theLastTimeStep));
      }
    } else if (isAlgorithmIn(new PDDcopAlgorithm[] { PDDcopAlgorithm.LS_SDPOP, PDDcopAlgorithm.FORWARD,
        PDDcopAlgorithm.HYBRID, PDDcopAlgorithm.REACT })) {
      for (int i = 0; i <= theLastTimeStep; i++) {
        if (dcop_algorithm == DcopAlgorithm.DPOP) {
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));
        } else if (dcop_algorithm == DcopAlgorithm.MGM) {
          mainSequentialBehaviourList.addSubBehaviour(new MGM_RAND_PICK_VALUE(this, i));
          for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
            mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_VALUE(this, i));
            mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_IMPROVE(this, i));
            mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_UTIL(this, i, localTS));
          }
        }
      }
    } else if (pddcop_algorithm == PDDcopAlgorithm.BACKWARD) {
      for (int i = theLastTimeStep; i >= 0; i--) {
        if (dcop_algorithm == DcopAlgorithm.DPOP) {
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
          mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));
        } else if (dcop_algorithm == DcopAlgorithm.MGM) {
          mainSequentialBehaviourList.addSubBehaviour(new MGM_RAND_PICK_VALUE(this, i));
          for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
            mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_VALUE(this, i));
            mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_IMPROVE(this, i));
            mainSequentialBehaviourList.addSubBehaviour(new MGM_SEND_RECEIVE_UTIL(this, i, localTS));
          }
        }
      }
    } else if (pddcop_algorithm == PDDcopAlgorithm.LS_RAND) {
      mainSequentialBehaviourList.addSubBehaviour(new LS_RAND_PICK_VALUE(this));
    } else if (pddcop_algorithm == PDDcopAlgorithm.R_LEARNING) {
      // Behaviors for learning the R function
      // Solving DCOP with current state ~ similar to REACT
      // Solving DCOP with the next state ~ similar to REACT
      // Behaviors for running the online version
      for (int i = 0; i <= rLearningIteration - 1; i++) {
        // Solving for current state
        isSolvingForCurrentState = true;
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));       
        // Update R and average reward only when having the solution of the previous state and the current state
        if (i > 0) {
          mainSequentialBehaviourList.addSubBehaviour(new R_LEARNING_UPDATE(this, i-1));
        }
      }
      
      // Mapping R-learning to DCOPs and solve for solution
      for (int i = 0; i <= theLastTimeStep; i++) {
        // R-learning values are converted into utility function in DPOP_UTIL
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));
      }
    }

    // Add the discounted tables to time steps 0 -> lastTimeStep for all algorithms
    // In order to compute solution quality of PD-DCOP
    // Not used for solving PD-DCOPs
    for (int timeIndex = 0; timeIndex <= horizon; timeIndex++) {
      discountedExpectedTableEachTSMap.get(timeIndex)
          .addAll(computeDiscountedDecisionTableList(rawDecisionTableList, timeIndex, discountFactor));
      discountedExpectedTableEachTSMap.get(timeIndex)
          .addAll(computeDiscountedExpectedRandomTableList(rawRandomTableList, timeIndex, discountFactor));
    }

    // Behaviors for local search approaches of PD-DCOPs
    if (isAlgorithmIn(new PDDcopAlgorithm[] { PDDcopAlgorithm.LS_RAND, PDDcopAlgorithm.LS_SDPOP })) {
      mainSequentialBehaviourList.addSubBehaviour(new INIT_PROPAGATE_DPOP_VALUE(this));
      mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_DPOP_VALUE(this));
      mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_SEND_LS_UTIL(this));

      for (int localTS = 0; localTS <= MAX_ITERATION; localTS++) {
        mainSequentialBehaviourList.addSubBehaviour(new LS_SEND_IMPROVE(this, theLastTimeStep, localTS));
        mainSequentialBehaviourList.addSubBehaviour(new LS_RECEIVE_IMPROVE(this, theLastTimeStep, localTS));
        mainSequentialBehaviourList.addSubBehaviour(new LS_RECEIVE_VALUE(this, theLastTimeStep, localTS));
        mainSequentialBehaviourList.addSubBehaviour(new LS_RECEIVE_SEND_LS_UTIL(this, theLastTimeStep, localTS));
      }
    }

    mainSequentialBehaviourList.addSubBehaviour(new SEND_RECEIVE_FINAL_VALUE(this));
    mainSequentialBehaviourList.addSubBehaviour(new SEND_RECEIVE_FINAL_UTIL(this));

    mainSequentialBehaviourList.addSubBehaviour(new AGENT_TERMINATE(this));
    
    return mainSequentialBehaviourList;
	}

	@SuppressWarnings("unused")
  private List<TableString> computeDpopBoundRandomTable(List<TableString> randTableList, SortedMap<String, String> mapping) {
		List<TableString> resultingList = new ArrayList<>();

		for (TableString randTable : randTableList) {
			String randVariable = randTable.getRandVarLabel().get(0);
			String randValue = mapping.get(randVariable);

			TableString table = new TableString(randTable.getDecVarLabel(), false);
			for (RowString row : table.getRowList()) {
				if (row.getRandomList().contains(randValue)) {
					table.addRow(new RowString(row.getValueList(), row.getUtility()));
				}
			}

			resultingList.add(table);
		}

		return resultingList;
	}

	// Given a mapping: random variable -> List of values (domain)
	// Compute a set that contains mapping: random variable -> value
	@SuppressWarnings("unused")
  private SortedSet<SortedMap<String, String>> computeRandomCombinations(
			SortedMap<String, List<String>> randomVariableDomains) {
		SortedSet<SortedMap<String, String>> realizationCombinations = new TreeSet<>();

		SortedSet<String> randomVariableSortedSet = new TreeSet<>();
		randomVariableSortedSet.addAll(randomVariableDomains.keySet());

		// Convert randomVariableDomains into the array list that contains the sorted
		// set of values
		// In order to call Set.cartesianProduct
		List<SortedSet<String>> domainForCatesianProduct = new ArrayList<>();
		for (Entry<String, List<String>> entry : randomVariableDomains.entrySet()) {
			SortedSet<String> set = new TreeSet<>();
			set.addAll(entry.getValue());
			domainForCatesianProduct.add(set);
		}

		Set<List<String>> realizationSet = Sets.cartesianProduct(domainForCatesianProduct);

		for (List<String> entry : realizationSet) {
			int index = 0;

			SortedMap<String, String> realization = new TreeMap<>();
			for (String random : randomVariableSortedSet) {
				realization.put(random, entry.get(index));
				index++;
			}

			realizationCombinations.add(realization);
		}

		return realizationCombinations;
	}
	
	private void simulateActualValueForRLearning() {		
		// From there, simulate the value of random variables
		// The initial distribution has been assigned using the stationary distribution
		for (int indexTime = 0; indexTime <= rLearningIteration; indexTime++) {
			// Only simulate states for time step that was not used for simulation before
			if (!pickedRandomMap.containsKey(indexTime)) {
				// Since R_LEARNING is STATIONARY, the initial distribution is also the stationary distribution
				pickedRandomMap.put(indexTime, simulateOnlineValue(indexTime));	
			}
		}
	}

	/**
	 * REVIEWED <br>
	 * Simulate values for self random variable <br>
	 * Then compute distribution at every time step depending on the dynamic type
	 * <br>
	 * Return lastTimeStep=horizon if FINITE/ONLINE OR return lastTimeStep=horizon -
	 * 1 if INFINITE
	 * 
	 * @return
	 */
	private int simulateActualValueAndComputeDistribution() {
		int lastTimeStep = 0;

		if (dynamicType == DynamicType.FINITE_HORIZON || dynamicType == DynamicType.ONLINE || dynamicType == DynamicType.STATIONARY) {
			lastTimeStep = horizon;
		} else if (dynamicType == DynamicType.INFINITE_HORIZON) {
			lastTimeStep = horizon - 1;
		}

		if (!selfRandomVariableDomainMap.containsKey(agentID)) {
			return lastTimeStep;
		}

		int randomDomainSize = selfRandomVariableDomainMap.get(agentID).size();
		
		// Simulate for ONLINE
		if (dynamicType == DynamicType.ONLINE) {
			for (int indexTime = 0; indexTime <= horizon; indexTime++) {
				pickedRandomMap.put(indexTime, simulateOnlineValue(indexTime));
				
				if (pddcop_algorithm == PDDcopAlgorithm.HYBRID) {
					createProbabilityWithObservation(indexTime + 1);
				} else if (pddcop_algorithm == PDDcopAlgorithm.FORWARD && indexTime > 0) {
					probabilityAtEachTimeStepMap.get(agentID)[indexTime] = new double[randomDomainSize];
					computeExpectedProbabilityAtTimeStep(indexTime);
				}
			}
		}
		// Simulate for STATIONARY
		else if (dynamicType == DynamicType.STATIONARY) {
			// Initial distribution = Converged distribution
			computeStationaryDistributionAsInitial();
			
			// Simulate actual value of random variables
			for (int indexTime = 0; indexTime <= horizon; indexTime++) {
				pickedRandomMap.put(indexTime, simulateOnlineValue(indexTime));
				
				// Set the probability distribution of FORWARD STATIONARY to the INITIAL PROBABILITY DISTRIBUTION
				// Used for solving each DCOP with the same stationary distribution
				if (pddcop_algorithm == PDDcopAlgorithm.FORWARD) {
					probabilityAtEachTimeStepMap.get(agentID)[indexTime] = probabilityAtEachTimeStepMap.get(agentID)[0];
				}
			}
		}
		// Compute distributions for other dynamics
		// Compute up to horizon - 1 for INFINITE and horizon for FINITE
		else {
			// timeIndex = 0 is the initial probability distribution
			for (int timeIndex = 1; timeIndex <= lastTimeStep; timeIndex++) {
				probabilityAtEachTimeStepMap.get(agentID)[timeIndex] = new double[randomDomainSize];
				computeExpectedProbabilityAtTimeStep(timeIndex);
			}
		}

		if (dynamicType == DynamicType.INFINITE_HORIZON) {
			computeExpectedProbabilityAtTimeStep(MARKOV_CONVERGENCE_TIME_STEP);
		}

		return lastTimeStep;
	}
	
  public void sendByteObjectMessageWithTime(AID receiver, PiecewiseMultivariateQuadFunction content, int msgCode,
      long time) throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    GZIPOutputStream gzipOut = new GZIPOutputStream(baos);
    ObjectOutputStream objectOut = new ObjectOutputStream(gzipOut);
    objectOut.writeObject(content);
    objectOut.close();
    byte[] data = baos.toByteArray();

    ACLMessage message = new ACLMessage(msgCode);
    message.setByteSequenceContent(data);
    message.addReceiver(receiver);
    message.setLanguage(String.valueOf(time));
    send(message);
  }

	// JADE function: stop the Agent
	protected void takeDown() {
//		print("Agent " + agentID + " with threadID " + Thread.currentThread().getId()
//				+ " has SIMULATED TIME: " + simulatedTime / 1000000 + "ms");
		print("terminated");
		try {
			DFService.deregister(this);
		} catch (FIPAException e) {
			e.printStackTrace();
		}
	}

	/**
	 * REVIEWED
	 * 
	 * @param lastTimeStep
	 */
	public void sendImprove(int lastTimeStep) {
		startSimulatedTiming();

		List<Double> currentUtilityList = utilityLSMinusCostOverTS(chosenValueAtEachTSMap, lastTimeStep);

		List<Set<String>> domainAcrossTimeSteps = new ArrayList<Set<String>>();

		for (int ts = 0; ts <= lastTimeStep; ts++) {
			Set<String> linkedValueSet = new LinkedHashSet<>();
			for (String value : getSelfDomain()) {
				linkedValueSet.add(value);
			}
			domainAcrossTimeSteps.add(linkedValueSet);
		}

		Set<List<String>> cartesianProduct = Sets.cartesianProduct(domainAcrossTimeSteps);

		double maxUtility = -Double.MAX_VALUE;
		Map<Integer, String> bestValueMapTS = new HashMap<>();

		for (List<String> valueListTS : cartesianProduct) {
			double evaluation = cumulativeUtilityLSMinusCost(valueListTS);
			if (Double.compare(evaluation, maxUtility) > 0) {
				maxUtility = evaluation;
				for (int i = 0; i < valueListTS.size(); i++) {
					bestValueMapTS.put(i, valueListTS.get(i));
				}
			}
		}

		if (Double.compare(maxUtility, -Double.MAX_VALUE) > 0) {
			bestImproveValueMap.putAll(bestValueMapTS);
			List<Double> bestUtilityList = utilityLSMinusCostOverTS(bestImproveValueMap, lastTimeStep);
			for (int i = 0; i <= lastTimeStep; i++) {
				bestImproveUtilityMap.put(i, bestUtilityList.get(i) - currentUtilityList.get(i));
			}
		} else {
			bestImproveValueMap.clear();
		}

		stopSimulatedTiming();

		for (AID neighbor : neighborAIDSet) {
			sendObjectMessageWithTime(neighbor, bestImproveUtilityMap, MESSAGE_TYPE.LS_IMPROVE, simulatedTime);
		}
	}

	/**
	 * REVIEWED <br>
	 * Remove children and pseudoChildren constraint table
	 */
	public List<TableString> getTableWithoutChildrenAndPseudochilren(List<TableString> tableList) {
		Set<String> childAndPseudoChildrenStrSet = new HashSet<String>();

		for (AID childrenAID : childrenAIDSet) {
			childAndPseudoChildrenStrSet.add(childrenAID.getLocalName());
		}
		for (AID pseudoChildrenAID : pseudoChildrenAIDSet) {
			childAndPseudoChildrenStrSet.add(pseudoChildrenAID.getLocalName());
		}

		List<TableString> resultingTableList = new ArrayList<>();

		for (TableString constraintTable : tableList) {
			List<String> intersectList = new ArrayList<>(constraintTable.getDecVarLabel());

			intersectList.remove(agentID);
			intersectList.retainAll(childAndPseudoChildrenStrSet);

			if (intersectList.isEmpty()) {
				resultingTableList.add(constraintTable);
			}
		}

		return resultingTableList;
	}

	/**
	 * REVIEWED
	 * 
	 * @param valuesOverTS
	 * @return
	 */
	private double cumulativeUtilityLSMinusCost(List<String> valuesOverTS) {
		double sumUtility = 0;
		double sumCost = 0;

		for (int ts = 0; ts < valuesOverTS.size(); ts++) {
			List<TableString> tableList = discountedExpectedTableEachTSMap.get(ts);

			for (TableString constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVarList) {
					if (neighbor.equals(agentID))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}

		for (int i = 0; i < valuesOverTS.size() - 1; i++) {
			sumCost += Math.pow(discountFactor, i)
					* switchingCostFunction(valuesOverTS.get(i), valuesOverTS.get(i + 1));
		}
		return sumUtility - sumCost;
	}

	/**
	 * REVIEWED <br>
	 * Compute current local quality at each time step in MGM
	 * 
	 * @param timeStepValueMap
	 * @param timeStep
	 * @return
	 */
	private List<Double> utilityLSMinusCostOverTS(Map<Integer, String> timeStepValueMap, int timeStep) {
		List<Double> utilityList = new ArrayList<>();

		for (int ts = 0; ts <= timeStep; ts++) {
			double switchingCost = 0;
			double utility = 0;

			if (ts == 0) {
				switchingCost = Math.pow(discountFactor, 0)
						* switchingCostFunction(timeStepValueMap.get(0), timeStepValueMap.get(1));
			}
			// Switching cost function returns 0 if the second argument is null
			else {
				switchingCost = Math.pow(discountFactor, ts - 1)
						* switchingCostFunction(timeStepValueMap.get(ts - 1), timeStepValueMap.get(ts))
						+ Math.pow(discountFactor, ts)
								* switchingCostFunction(timeStepValueMap.get(ts), timeStepValueMap.get(ts + 1));
			}
			// from each utility constraint with neighbors at a timeStep
			// get names -> get values from agent_view
			// from neighbors' values, current value -> get utility from
			// constraint table
			List<TableString> tableList = discountedExpectedTableEachTSMap.get(ts);
			// System.err.println("Agent " + idStr + " size " +
			// tableList.size());

			for (TableString constraintTable : tableList) {
				List<String> decVariableList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVariableList) {
					if (neighbor.equals(agentID)) {
						decValueList.add(timeStepValueMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
					}
				}

				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}

			utilityList.add(utility - switchingCost);
		}

		return utilityList;
	}

	// utilityMinusCostOverTSList
	List<Double> utilityMinusCostOverTSList(List<String> valuesOverTS) {
		List<Double> utilityList = new ArrayList<Double>();
		for (int ts = 0; ts <= horizon; ts++) {
			double sc = 0;
			double utility = 0;
			if (ts == 0)
				// sc = (valuesOverTS.get(0).equals(valuesOverTS.get(1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(0), valuesOverTS.get(1));
			else if (ts == horizon)
				// sc = (valuesOverTS.get(h).equals(valuesOverTS.get(h-1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(horizon), valuesOverTS.get(horizon - 1));
			else
				// sc = (valuesOverTS.get(ts-1).equals(valuesOverTS.get(ts))
				// ? 0 : switchingCost)
				// + (valuesOverTS.get(ts).equals(valuesOverTS.get(ts+1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(ts - 1), valuesOverTS.get(ts))
						+ switchingCostFunction(valuesOverTS.get(ts), valuesOverTS.get(ts + 1));

			// from each utility constraint with neighbors at a timeStep
			// get names -> get values from agent_view
			// from neighbors' values, current value -> get utility from
			// constraint table
			List<TableString> tableList = discountedExpectedTableEachTSMap.get(ts);
			// System.err.println("Agent " + idStr + " size " +
			// tableList.size());
			for (TableString constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVarList) {
					if (neighbor.equals(agentID))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
				}
				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}

			utilityList.add(utility - sc);
		}
		return utilityList;
	}

	/**
	 * Assign the distribution for this time step given the observed value from the
	 * previous one
	 * 
	 * @param timeStep
	 */
	public void createProbabilityWithObservation(int timeStep) {
		if (timeStep == 0 || timeStep > horizon) {
			return;
		}

		String randVariable = agentID;

		double distribution[] = toArray(
				transitionFunctionMap.get(randVariable).getTransitionOf(pickedRandomMap.get(timeStep - 1)));
		probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = distribution;
	}

	/**
	 * Compute probability distribution at each time step <br>
	 * If timeStep = MARKOV_CONVERGENCE_TIME_STEP, compute the stationary
	 * distribution at horizon
	 * 
	 * @param timeStep
	 */
	public void computeExpectedProbabilityAtTimeStep(int timeStep) {
		for (String randVariable : selfRandomVariableDomainMap.keySet()) {
			if (timeStep == MARKOV_CONVERGENCE_TIME_STEP) {
				double[] probability = probabilityAtEachTimeStepMap.get(randVariable)[horizon - 1];
				for (int h = horizon - 1; h <= MARKOV_CONVERGENCE_TIME_STEP; h++) {
					probability = multiply(probability, transitionFunctionMap.get(randVariable));
				}
				probabilityAtEachTimeStepMap.get(randVariable)[horizon] = probability;
			} else {
				double[] prevDistribution = probabilityAtEachTimeStepMap.get(randVariable)[timeStep - 1];
				double[] currDistribution = multiply(prevDistribution, transitionFunctionMap.get(randVariable));
				probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = currDistribution;
			}
		}
	}
	
	/**
	 * Compute the stationary probability distribution and set it at the first time step
	 */
	public void computeStationaryDistributionAsInitial() {
		for (String randVariable : selfRandomVariableDomainMap.keySet()) {
			double[] probability = probabilityAtEachTimeStepMap.get(randVariable)[0];
			
			for (int h = 0; h <= MARKOV_CONVERGENCE_TIME_STEP; h++) {
				probability = multiply(probability, transitionFunctionMap.get(randVariable));
			}
			probabilityAtEachTimeStepMap.get(randVariable)[0] = probability;
		}
	}

	// for each agent, create probability for valueList at each timeStep of each
	// randomVariable
	// add to probabilityAtEachTimeStepMap
//	private void createAndAddProbabilityAtEachTimeStep() {
	// get each random Variable from randomVariableList
	// add to probabilityAtEachTimeStepMap
	// int columnNo = timeStepAllowed + 1;
//		int columnNo = horizon + 1;
//		for (int randVarIndex = 0; randVarIndex < selfVariableList.size(); randVarIndex++) {
//			String randVariable = selfVariableList.get(randVarIndex);
//			int domainSize = selfRandomVariableDomainMap.get(randVariable).size();
//			// each row is a timeStep from 0 to finalTimeStep
//			// each column is a value from domain
//			double[][] probAtEachTS = new double[columnNo][domainSize];
//			TransitionFunction transMatrix = transitionFunctionMap.get(randVariable);
//			for (int row = 0; row < columnNo; row++) {
//				if (row == 0) {
//					List<Double> initProbList = initProabilityMap.get(randVariable);
//					for (int col = 0; col < domainSize; col++) {
//						probAtEachTS[row][col] = initProbList.get(col);
//					}
//					continue;
//				}
//				for (int col = 0; col < domainSize; col++) {
//					double probabilityAtATime = 0;
//					for (int upperCol = 0; upperCol < domainSize; upperCol++) {
//						probabilityAtATime += probAtEachTS[row - 1][upperCol]
//								* transMatrix.getProbByIndex(upperCol, col);
//					}
//					probAtEachTS[row][col] = probabilityAtATime;
//				}
//			}
//			probabilityAtEachTimeStepMap.put(randVariable, probAtEachTS);
//		}
//	}

	public List<List<String>> getAllTupleValueOfGivenLabeUsingCartesianProduct(List<String> varLabel,
			boolean isDecVar) {
		List<Set<String>> valueSetList = new ArrayList<Set<String>>();

		for (String decisionVariable : varLabel) {
			Set<String> linkedValueSet = new LinkedHashSet<>();
			if (isDecVar) {
				linkedValueSet.addAll(decisionVariableDomainMap.get(decisionVariable));
			} else {
				linkedValueSet.addAll(selfRandomVariableDomainMap.get(decisionVariable));
			}
			valueSetList.add(linkedValueSet);
		}

		Set<List<String>> cartesianProduct = Sets.cartesianProduct(valueSetList);

		List<List<String>> finalList = new ArrayList<>();
		for (List<String> valueList : cartesianProduct) {
			finalList.add(valueList);
		}

		return finalList;
	}

	/**
	 * @param varLabel
	 * @param isDecVar
	 * @return
	 */
	public List<List<String>> getAllTupleValueOfGivenLabel(List<String> varLabel, boolean isDecVar) {
		List<List<String>> allTuple = new ArrayList<List<String>>();
		List<Integer> sizeDomainList = new ArrayList<Integer>();
		int totalDomainSize = 1;

		for (String randVar : varLabel) {
			int domainSize = 0;

			if (isDecVar) {
				domainSize = decisionVariableDomainMap.get(randVar).size();
			} else {
				domainSize = selfRandomVariableDomainMap.get(randVar).size();
			}
			sizeDomainList.add(domainSize);
			totalDomainSize *= domainSize;
		}

		int noVar = varLabel.size();

		// go from 0 to totalSize
		for (int count = 0; count < totalDomainSize; count++) {
			List<String> valueTuple = new ArrayList<String>();
			int quotient = count;
			// for each value count, decide the index of each column, then add
			// to the tuple
			for (int varIndex = noVar - 1; varIndex >= 0; varIndex--) {
				int remainder = quotient % sizeDomainList.get(varIndex);
				quotient = quotient / sizeDomainList.get(varIndex);
				if (isDecVar) {
					valueTuple.add(decisionVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
				} else {
					valueTuple.add(selfRandomVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
				}
			}
			Collections.reverse(valueTuple);
			allTuple.add(valueTuple);
		}

		return allTuple;
	}

//	public double getUtilityFromTableGivenDecAndRand(Table table, List<String> decValueList,
//			List<String> randIterationValue) {
//		List<Row> tableToTraversed = table.getRowList();
//		for (Row row : tableToTraversed) {
//			boolean isRowFound = true;
//			// System.err.println("Utility of this row " + row.getUtility());
//			List<String> rowValueList = row.getValueList();
//			List<String> rowRandomList = row.getRandomList();
//
//			if (rowValueList.size() != decValueList.size() || rowRandomList.size() != randIterationValue.size()) {
//				System.err.println("!!!!!!Different size!!!!!!!!!");
//				System.err.println("!!!!!!Recheck your code!!!!!!");
//			}
//			for (int index = 0; index < decValueList.size(); index++) {
//				if (rowValueList.get(index).equals(decValueList.get(index)) == false) {
//					isRowFound = false;
//					break;
//				}
//			}
//
//			if (isRowFound == false)
//				continue;
//
//			for (int index = 0; index < randIterationValue.size(); index++) {
//				if (rowRandomList.get(index).equals(randIterationValue.get(index)) == false) {
//					isRowFound = false;
//					break;
//				}
//			}
//
//			if (isRowFound == false)
//				continue;
//
//			return row.getUtility();
//		}
//		print("Not found!!!!!!!!!!!!!!");
//		return Integer.MIN_VALUE;
//	}

	public void sendObjectMessage(AID receiver, Object content, int msgCode) {
		ACLMessage message = new ACLMessage(msgCode);

		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		send(message);

		print("send message " + content + " to agent " + receiver.getLocalName());
	}

	public void sendStringMessage(AID receiver, String content, int msgCode) {
		ACLMessage message = new ACLMessage(msgCode);
		message.setContent(content);
		message.addReceiver(receiver);
		send(message);

		print("sends message type " + MESSAGE_TYPE.msgTypes.get(msgCode) + " to agent " + receiver.getLocalName() + ": "
				+ content);
	}

	public void sendObjectMessageWithTime(AID receiver, Object content, int msgCode, long time) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		message.setLanguage(String.valueOf(time));
		send(message);

		if (msgCode != MESSAGE_TYPE.DPOP_UTIL) {
			print("sends message type " + MESSAGE_TYPE.msgTypes.get(msgCode) + " to agent " + receiver.getLocalName()
					+ ": " + content);
		} else {
			print("sends message type " + MESSAGE_TYPE.msgTypes.get(msgCode) + " to agent " + receiver.getLocalName());
		}
	}

	public void printTree() {
		print("************");
		print("My ID is: " + agentID);
		if (!isRoot)
			print("My parent is: " + parentAID.getLocalName());
		print("My children are: ");

		for (AID children : childrenAIDSet) {
			System.out.print(children.getLocalName() + " ");
		}

		print();

		print("My pseudo_parents are: ");

		for (AID pseudoParent : pseudoParentAIDSet) {
			System.out.print(pseudoParent.getLocalName() + " ");
		}
		print();

		print("My pseudo_children are: ");
		for (AID pseudoChild : pseudoChildrenAIDSet) {
			System.out.print(pseudoChild.getLocalName() + " ");
		}
		print();
	}
	
  /**
   * THIS METHOD HAS BEEN REIVEWED AND TESTED
   * @param inputFileName
   */
  private void parseInputFileContinuous(String inputFileName) {
    int maxNumberOfNeighbors = Integer.MIN_VALUE;

    final String DECISION_VARIABLE = "decision_";
    final String RANDOM_VARIABLE = "random_";
    final String FUNCTION = "function";

    final String INIT_PROB_PREFIX = "initial_distribution_";
    final String TRANS_FUNC_PREFIX = "transition_";
    final String NEIGHBOR_SET = "neighbor_set_";

    try (BufferedReader br = new BufferedReader(new FileReader(System.getProperty("user.dir") + "/" + inputFileName))) {
      List<String> lineListWithoutSemicolon = new ArrayList<String>();

      String line = br.readLine();
      while (line != null) {
        if (line.length() == 0 || line.startsWith("%") == true) {
          line = br.readLine();
          continue;
        }

        // concatenate line until meet ';'
        if (line.endsWith(";") == false) {
          do {
            line += br.readLine();
          } while (line.endsWith(";") == false);
        }

        line = line.replace(";", "");
        lineListWithoutSemicolon.add(line);
        line = br.readLine();
      }

      // Process line by line;
      for (String lineWithoutSemicolon : lineListWithoutSemicolon) {
        String leftHandSide = lineWithoutSemicolon.split("=")[0];
        String rightHandSide = lineWithoutSemicolon.split("=")[1];

        /** DECISION_VARIABLE */
        // read decision variable domain
        if (leftHandSide.contains(DECISION_VARIABLE)) {
          // process name
          String decisionVariable = leftHandSide.replace(DECISION_VARIABLE, "");

          // process values
          rightHandSide = rightHandSide.replace("[", "");
          rightHandSide = rightHandSide.replace("]", "");
          double lowerBound = Double.valueOf(rightHandSide.split(",")[0]);
          double upperBound = Double.valueOf(rightHandSide.split(",")[1]);
          decisionVariableList.add(decisionVariable);
          decisionVariableIntervalMap.put(decisionVariable, new Interval(lowerBound, upperBound));
        }
        else if (leftHandSide.contains(RANDOM_VARIABLE)) {
          // process name
          String randomVariable = leftHandSide.replace(RANDOM_VARIABLE, "");

          // process values
          rightHandSide = rightHandSide.replace("[", "").replace("]", "");
          double lowerBound = Double.valueOf(rightHandSide.split(",")[0]);
          double upperBound = Double.valueOf(rightHandSide.split(",")[1]);

          randomVariableIntervalMap.put(randomVariable, new Interval(lowerBound, upperBound));
        }
        /** FUNCTION */
        // function(x3,x1)=9.386x3^2 -5.77744x3 -3.91612x1^2 -6.10079x1 -6.70358x3x1
        // 7.41036;
        // BinaryFunction func = new BinaryFunction(-1, 20, -3, 40, -2, 6)
        // Double.valueOf(idStr), 1.0);
        else if (leftHandSide.startsWith(FUNCTION)) {
          // x1^ and x10^
          // Only read the function associated with self variable
          if (!rightHandSide.contains(getLocalName() + "^"))
            continue;

          String functionHead = leftHandSide.replace(FUNCTION + "(", "").replace(")", "");
          String[] scope = functionHead.split(",");
//          String selfAgent = "x" + agentID;
          String neighborAgent = scope[0].equals(getLocalName()) ? scope[1] : scope[0];
          
          String[] termStrList = rightHandSide.split(" ");
          String[] functionParamters = parseFunction(termStrList, getLocalName(), neighborAgent);

          print("functionParamters=" + Arrays.deepToString(functionParamters));

          MultivariateQuadFunction func = new MultivariateQuadFunction(functionParamters, getLocalName(), neighborAgent);

          // Adding the new neighbor to neighborStrSet if this is not a random variable
          if (!neighborAgent.contains(RANDOM_PREFIX)) {
            neighborStrSet.add(neighborAgent);
          }

          PiecewiseMultivariateQuadFunction pwFunc = new PiecewiseMultivariateQuadFunction();
          // creating the interval map
          Map<String, Interval> intervalMap = new HashMap<>();
          intervalMap.put(getLocalName(), decisionVariableIntervalMap.get(getLocalName()));

          if (!neighborAgent.contains(RANDOM_PREFIX)) {
            intervalMap.put(neighborAgent, decisionVariableIntervalMap.get(neighborAgent)); 
          } else {
            intervalMap.put(neighborAgent, randomVariableIntervalMap.get(neighborAgent));
          }

          pwFunc.addToFunctionMapWithInterval(func, intervalMap, NOT_TO_OPTIMIZE_INTERVAL);
          neighborFunctionMap.put(neighborAgent, pwFunc);
          
          // Set the functions that I own. Functions are binary
          // Do not add random function to MSFunctionMapIOwn
          if (isRunningMaxsum() && getLocalName().compareTo(neighborAgent) < 0) {
            // add the function to Maxsum function map
            // add the neighbor to external-var-agent-set
            MSFunctionOwnedByMeMap.put(neighborAgent, pwFunc);
          }
        }
        else if (leftHandSide.contains(INIT_PROB_PREFIX)) {
          String randomVariable = leftHandSide.replace(INIT_PROB_PREFIX, "");

          // process values
          rightHandSide = rightHandSide.replace("[", "");
          rightHandSide = rightHandSide.replace("]", "");
          
          // alpha=1.2,beta=3.4565
          double alpha = Double.valueOf(rightHandSide.split(",")[0].replace("alpha:", ""));
          double beta = Double.valueOf(rightHandSide.split(",")[1].replace("beta:", ""));

          RandomGenerator rg = new Well19937c(DEFAULT_BETA_SAMPLING_SEED);
          initialDistributionMap.put(randomVariable, new BetaDistribution(rg, alpha, beta));
        }
        else if (leftHandSide.contains(TRANS_FUNC_PREFIX)) {
          String randomVariable = leftHandSide.replace(TRANS_FUNC_PREFIX, "");

          // process values
          rightHandSide = rightHandSide.replace("[", "");
          rightHandSide = rightHandSide.replace("]", "");

          // alpha=1.2
          double alpha = Double.valueOf(rightHandSide.replace("alpha:", ""));
          transitionDistributionFamilyMap.put(randomVariable, TransitionFamilyDistribution.of(alpha));
        }
        else if (leftHandSide.startsWith(NEIGHBOR_SET)) {
          String agent = leftHandSide.replace(NEIGHBOR_SET, "");
          // neighbor_set_x1=x11 x3 y1
          // x1: x11 x3 y1
          // x11 x3 y1
          String neighborSetStr = rightHandSide;
          // Do not consider random variable
          // neighbor set: y1: x1 ;
          if (!agent.contains(RANDOM_PREFIX)) {
            Set<String> neighborSet = new HashSet<>();

            for (String neighbor : neighborSetStr.split(" ")) {
              if (!neighbor.contains(RANDOM_PREFIX)) {
                neighborSet.add(neighbor);
              }
            }

            neighborSetMap.put(agent, neighborSet);
            agentHeuristicStringMap.put(agent, (double) neighborSet.size());

            if (neighborSet.size() > maxNumberOfNeighbors) {
              rootAgent = agent;
              maxNumberOfNeighbors = neighborSet.size();
            }
          }
        }
      }
      
      print("MSFunctionMapIOwn=" + MSFunctionOwnedByMeMap);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

	private void parseInputFileDiscrete(String inputFileName) {
		final String DECISION_VARIABLE = "decision";
		final String RANDOM_VARIABLE = "random";
		final String REWARD_TABLE_PREFIX = "constraint";
		final String TRANS_FUNC_PREFIX = "transition";
		final String INIT_PROB_PREFIX = "initial_distribution";

		Map<String, Set<String>> neighborSetMap = new HashMap<>();
		Map<String, Integer> randHeuristicMap = new HashMap<>();
		Set<String> allRandomVariableSet = new HashSet<>();

		try (BufferedReader br = new BufferedReader(
				new FileReader(System.getProperty("user.dir") + '/' + inputFileName))) {
			List<String> lineWithSemiColonList = new ArrayList<String>();

			String line = br.readLine();
			while (line != null) {
				if (line.length() == 0 || line.startsWith("%") == true) {
					line = br.readLine();
					continue;
				}

				// concatenate lines until meet ';'
				if (!line.endsWith(";")) {
					do {
						line += br.readLine();
					} while (line.endsWith(";") == false);
				}

				line = line.replace(" ", "");
				line = line.replace(";", "");

//				if (isPrinting()) {
//          print(line);
//        }

				lineWithSemiColonList.add(line);
				line = br.readLine();
			}

			// Process line by line;
			for (String lineWithSemiColon : lineWithSemiColonList) {
				// print input file for agent0
				String nameMzn = lineWithSemiColon.split("=")[0];
				String valueMzn = lineWithSemiColon.split("=")[1];

				/** DECISION_VARIABLE */
				// read decision variable domain
				if (nameMzn.contains(DECISION_VARIABLE)) {
					// process name
					String decisionVariable;
					List<String> valueOfDecisionVariableList = new ArrayList<>();
					decisionVariable = nameMzn.replace(DECISION_VARIABLE + "_x", "");

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					for (int value = Integer.parseInt(valueMzn.split(",")[0]); value <= Integer
							.parseInt(valueMzn.split(",")[1]); value++) {
						valueOfDecisionVariableList.add(String.valueOf(value));
					}

					decisionVariableList.add(decisionVariable);
					decisionVariableDomainMap.put(decisionVariable, valueOfDecisionVariableList);

//          if (isPrinting()) {
//            print("decisionVariableList " + decisionVariableList);
//            print("decisionVariableDomainMap " + decisionVariableDomainMap);
//          }
				}
				/** RANDOM_VARIABLE */
				// read decision variable domain
				if (nameMzn.contains(RANDOM_VARIABLE)) {
					// process name
					String randomVariable;
					List<String> randomDomain = new ArrayList<>();
					randomVariable = nameMzn.replace(RANDOM_VARIABLE + "_y", "");

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					for (int value = Integer.parseInt(valueMzn.split(",")[0]); value <= Integer
							.parseInt(valueMzn.split(",")[1]); value++) {
						randomDomain.add(String.valueOf(value));
					}

					allRandomVariableSet.add(randomVariable);

					boundDpopRandomDomains.put(randomVariable, randomDomain);

					// Only add self random variable if any
					if (randomVariable.equals(agentID)) {
						selfRandomVariableDomainMap.put(randomVariable, randomDomain);
					}

//          if (isPrinting()) {
//            print("randomVariableDomainMap " + selfRandomVariableDomainMap);
//          }
				}
				/** TRANS_FUNC_PREFIX */
				if (nameMzn.contains(TRANS_FUNC_PREFIX)) {
					String randomVariable;
					List<List<Double>> newTransitionMatrix;

					randomVariable = nameMzn.replaceAll(TRANS_FUNC_PREFIX + "_y", "");

					// Read variables related to agentID only
					if (!randomVariable.equals(agentID)) {
						continue;
					}

					/** create transition function **/
					newTransitionMatrix = new ArrayList<List<Double>>();
					List<String> listOfRow;
					/** process table values **/
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
//					valueMzn = valueMzn.substring(1, valueMzn.length() - 1);
					listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
					for (String oneRow : listOfRow) {
						List<String> valueStrList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
						List<Double> valueDoubleList = new ArrayList<Double>();

						for (String valueStr : valueStrList) {
							valueDoubleList.add(Double.parseDouble(valueStr));
						}
						newTransitionMatrix.add(valueDoubleList);
					}
					TransitionFunction newTransitionFunction = new TransitionFunction(
							selfRandomVariableDomainMap.get(randomVariable), newTransitionMatrix);
					transitionFunctionMap.put(randomVariable, newTransitionFunction);

//          if (isPrinting()) {
//            print("transitionFunctionMap " + transitionFunctionMap);
//          }
				}
				/** INIT_PROB_PREFIX */
				if (nameMzn.contains(INIT_PROB_PREFIX)) {
					String randomVariable;
					List<String> initProbabilityStrList;
//					List<Double> initProbabilityDoubleList = new ArrayList<Double>();
					nameMzn = nameMzn.replace(INIT_PROB_PREFIX + "_y", "");
					randomVariable = nameMzn;

//					 Read variable with agentID only
					if (!randomVariable.equals(agentID)) {
						continue;
					}

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					initProbabilityStrList = new ArrayList<>(Arrays.asList(valueMzn.split(",")));

					int randomDomainSize = initProbabilityStrList.size();
					probabilityAtEachTimeStepMap.put(randomVariable, new double[horizon + 1][randomDomainSize]);

					for (int i = 0; i < initProbabilityStrList.size(); i++) {
						probabilityAtEachTimeStepMap.get(randomVariable)[0][i] = Double
								.parseDouble(initProbabilityStrList.get(i));
					}

//          if (isPrinting()) {
//            print("initProabilityMap " + Arrays.toString(probabilityAtEachTimeStepMap.get(randomVariable)[0]));
//          }
				}
				/** REWARD_TABLE_PREFIX */
				/**
				 * process name of constraint table, create table with the corresponding name
				 **/
				if (nameMzn.contains(REWARD_TABLE_PREFIX)) {
					nameMzn = nameMzn.replaceAll(REWARD_TABLE_PREFIX + "_", "");

					TableString newRewardTable;
					List<String> variableLabel = new ArrayList<String>(Arrays.asList(nameMzn.split("_")));
					List<String> listOfRow;

					// Do not add random variables to the neighbor list
					if (!nameMzn.contains("y")) {
						String var1 = variableLabel.get(0).replace("x", "");
						String var2 = variableLabel.get(1).replace("x", "");

						neighborSetMap.computeIfAbsent(var1, x -> new HashSet<>()).add(var2);
						neighborSetMap.computeIfAbsent(var2, x -> new HashSet<>()).add(var1);
					}

					if (!variableLabel.contains("x" + agentID)) {
						continue;
					}
					/**** WITHOUT random variable **********/
					boolean notContainRandom = true;
					for (String var : variableLabel) {
						if (var.contains("y")) {
							notContainRandom = false;
							break;
						}
					}
					if (notContainRandom) {
						/** add variable to neighborList **/
						List<String> variableLabel_new = new ArrayList<>();
						for (String var : variableLabel) {
							/* add to neighbor list */
							var = var.replace("x", "");
							if (!var.equals(agentID) && !neighborStrSet.contains(var)) {
								neighborStrSet.add(var);
							}
							variableLabel_new.add(var);
						}
						/** create Table **/
						newRewardTable = new TableString(variableLabel_new, DECISION_TABLE);

						/** process table values **/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");

						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));

						for (String oneRow : listOfRow) {
							List<String> valueList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
							double utility = Double.parseDouble(valueList.get(valueList.size() - 1));
							valueList.remove(valueList.size() - 1);
							RowString newRow = new RowString(valueList, utility);
							newRewardTable.addRow(newRow);
						}
//						constraintTableWithoutRandomList.add(newRewardTable);
						rawDecisionTableList.add(newRewardTable);
//						
//	          if (isPrinting()) {
//	            print("rawDecisionTableList " + rawDecisionTableList);
//	          }
					}
					/**** WITH random variable **********/
					else {
						/** Process nameMzn */
						int decisionVarCount = 0;
						List<String> decVarLabel = new ArrayList<String>();
						List<String> randVarLabel = new ArrayList<String>();
						for (String var : variableLabel) {
							if (var.startsWith("x")) {
								decisionVarCount++;
								decVarLabel.add(var.replace("x", ""));
							} else if (var.startsWith("y")) {
								randVarLabel.add(var.replace("y", ""));
							}
						}
						/** add variable to neighborList **/
						for (String var : decVarLabel) {
							/* add to neighbor list */
							if (!var.equals(agentID)) {
								neighborStrSet.add(var);
							}
						}
						/** create Table **/
						// print("!" + decVarLabel + " " +
						// randVarLabel);
						newRewardTable = new TableString(decVarLabel, randVarLabel, RANDOM_TABLE);

						/** process table values **/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");
						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
						for (String oneRow : listOfRow) {
							List<String> decAndRandValueList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
							List<String> decValueList = new ArrayList<String>();
							List<String> randValueList = new ArrayList<String>();
							double utility = Double
									.parseDouble(decAndRandValueList.get(decAndRandValueList.size() - 1));

							decAndRandValueList.remove(decAndRandValueList.size() - 1);
							for (int i = 0; i < decisionVarCount; i++) {
								decValueList.add(decAndRandValueList.get(i));
							}
							for (int i = decisionVarCount; i < decAndRandValueList.size(); i++) {
								randValueList.add(decAndRandValueList.get(i));
							}
							RowString newRow = new RowString(decValueList, randValueList, utility);
							newRewardTable.addRow(newRow);
						}
						rawRandomTableList.add(newRewardTable);
//            if (isPrinting()) {
//              print("rawRandomTableList " + rawRandomTableList);
//            }
					}
				}
			}

			// Compute randHeuristicMap
			for (Entry<String, Set<String>> entry : neighborSetMap.entrySet()) {
				String agent = entry.getKey();
				int count = 0;
				for (String neighbor : entry.getValue()) {
					if (allRandomVariableSet.contains(neighbor)) {
						count++;
					}
				}

				randHeuristicMap.put(agent, count);
			}

    // Compute heuristic values for each agent
      SortedSet<String> allAgents = new TreeSet<>(neighborSetMap.keySet());
      double maxValue = -Double.MAX_VALUE;

      for (String agent : allAgents) {
        int agentRandHeuristic = (allRandomVariableSet.contains(agent) ? 1 + 1 : 1 + 0)
            * randHeuristicMap.get(agent);
        double value = heuristicWeight * agentRandHeuristic
            + (1 - heuristicWeight) * neighborSetMap.get(agent).size();
        agentHeuristicStringMap.put(agent, value);

        if (Double.compare(value, maxValue) > 0) {
          maxValue = value;
          rootAgent = agent;
        }
      }
			/** Place to test printing out */
			/** end of testing */
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public boolean isRunningMaxsum() {
		return dcop_algorithm == DcopAlgorithm.MAXSUM 
		    || dcop_algorithm == DcopAlgorithm.HYBRID_MAXSUM 
		    || dcop_algorithm == DcopAlgorithm.CAC_MAXSUM;
	}
	
	// 9.386x3^2 -5.77744x3 -3.91612x1^2 -6.10079x1 -6.70358x3x1 7.41036
	// 9.386x3^2 -5.77744x3 -3.91612y3^2 -6.10079y3 -6.70358x3y3 7.41036
	/**
	 * THIS FUNCTION HAS BEEN TESTED BY PRINTING OUT <br>
	 * Note do not change String[] to Double[] since the array also contains the name of neighborAgent <br>
	 * @param termArray
	 * @param selfAgent
	 * @param neighborAgent
	 * @return
	 */
	public String[] parseFunction(String[] termArray, String selfAgent, String neighborAgent) {
	  boolean hasRandom = neighborAgent.contains(RANDOM_PREFIX);
	  
	  String coeffArray[] = new String[7];
		coeffArray[6] = neighborAgent;
		
		String otherVarPrefix = hasRandom ? "y" : "x";
		
		for (String term : termArray) {
			// -281x1^2
			if (term.contains(selfAgent + "^2")) {
				coeffArray[0] = term.replace(selfAgent + "^2", "");
			}
			// -22x10^2
			// -22y10^2
			else if (term.contains("^2")) {
				term = term.replace("^2", "");
				coeffArray[2] = term.split(otherVarPrefix)[0];
			}
			// constant 358
			else if (!term.contains("x") && !term.contains("y")) {
				coeffArray[5] = term;

			}
			// 288x1x10 OR 252x10 OR 199x1
			// 288x1y10 OR 252y10 OR 199x1
			// split the "x_"
			// count for number of element
			// then comparing number
			// done
			else {
				// 288x1x10 or 288x1y10
				if (term.contains(selfAgent + neighborAgent) || term.contains(neighborAgent + selfAgent)) {
					coeffArray[4] = term.split("x")[0]; // assuming that x stands before y
				}
				// 199x1 OR 199x10 OR 199y1 OR 199y10
				else if (term.endsWith(selfAgent)) {
					coeffArray[1] = term.replace(selfAgent, "");
				}
				else {
					coeffArray[3] = term.replace(neighborAgent, "");
				}
			}
		}
		
		return coeffArray;
	}

	public boolean isPrinting() {
		return agentID.equals("2");
	}

	public void registerWithDF() {
		DFAgentDescription dfd = new DFAgentDescription();
		dfd.setName(getAID());

		for (String neighborStr : neighborStrSet) {
			ServiceDescription sd = new ServiceDescription();
			sd.setType(neighborStr.replace("x", ""));
			sd.setName(agentID);
			dfd.addServices(sd);
		}

//		for (int i = 0; i < neighborStrSet.size(); i++) {
//			ServiceDescription sd = new ServiceDescription();
//			sd.setType(neighborStrSet.get(i));
//			sd.setName(agentID);
//			dfd.addServices(sd);
//		}

		try {
			DFService.register(this, dfd);
		} catch (FIPAException fe) {
			fe.printStackTrace();
		}
	}

	/**
	 * @return the actual local solution quality at the subtree in ACTUAL_UTIL phase
	 */
	public double computeActualUtilityWithParentAndPseudoParent() {
		double sumUtility = 0;

		for (int ts = 0; ts < chosenValueAtEachTSMap.size(); ts++) {
			List<TableString> tableList = actualDpopTableAcrossTimeStep.get(ts);

			for (TableString constraintTable : tableList) {
				List<String> decisionLabel = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();

				for (String variableInLabel : decisionLabel) {
					if (variableInLabel.equals(agentID)) {
						decValueList.add(chosenValueAtEachTSMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(variableInLabel).get(ts));
					}
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}

		return sumUtility;
	}

	/**
	 * REVIEWED <br>
	 * 
	 * Get utility with parents and pseudoparents, then add its switching cost
	 * 
	 * @param timeSteps
	 * @return
	 */
	public double utilityLSWithParentAndPseudoAndUnary() {
		double sumUtility = 0;

		for (int ts = 0; ts <= horizon; ts++) {
			List<TableString> tableList = discountedExpectedTableEachTSMap.get(ts);

			for (TableString constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();

				// Only consider tables with parent and pseudo-parents
				// And unary constraint
				List<String> decLabelMinusAgent = new ArrayList<String>(decVarList);
				decLabelMinusAgent.remove(agentID);
				if (!parentAndPseudoStrList.containsAll(decLabelMinusAgent)) {
					continue;
				}

				for (String variableInList : decVarList) {
					if (variableInList.equals(agentID)) {
						decValueList.add(chosenValueAtEachTSMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(variableInList).get(ts));
					}
				}

				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}

		return sumUtility;
	}
	
	 /**
   * REVIEWED <br>
   * 
   * Get utility with parents and pseudoparents, then add its switching cost
   * 
   * @param timeSteps
   * @return
   */
  public double utilityLSWithParentAndPseudoAndUnaryContinuous() {
    double sumUtility = 0;

    for (int ts = 0; ts <= horizon; ts++) {
      for (Entry<String, PiecewiseMultivariateQuadFunction> functionEntry : functionWithPParentMap.entrySet()) {
        String ppParent = functionEntry.getKey();
        PiecewiseMultivariateQuadFunction function = functionEntry.getValue();
        
        Map<String, Double> domainMap = new HashMap<>();
        domainMap.put(getLocalName(), chosenDoubleValueAtEachTSMap.get(ts));
        domainMap.put(ppParent, agentViewDoubleEachTimeStepMap.get(ppParent).get(ts));

        sumUtility += Math.pow(discountFactor, ts) * function.getTheFirstFunction().evaluateToValueGivenValueMap(domainMap);
      }
      
      if (hasRandomFunction()) {
        PiecewiseMultivariateQuadFunction expectedFunction = expectedFunctionMap.get(ts);
        Map<String, Double> domainMap = new HashMap<>();
        domainMap.put(getLocalName(), chosenDoubleValueAtEachTSMap.get(ts));
        
        sumUtility += Math.pow(discountFactor, ts) * expectedFunction.getTheFirstFunction().evaluateToValueGivenValueMap(domainMap);
      }
    }

    return sumUtility;
  }

	public List<String> getSelfDomain() {
		return decisionVariableDomainMap.get(agentID);
	}

	/**
	 * REVIEWED <br>
	 * 
	 * Return switching cost in positive values
	 * 
	 * @return
	 */
	public double computeSwitchingCostAllTimeStep() {
		double switchingCost = 0;

		if (chosenValueAtEachTSMap.size() == 1) {
			return Double.MAX_VALUE;
		}

		// Compute switching costs from the first time step to the horizon
		for (int timeStep = 0; timeStep < horizon; timeStep++) {
			switchingCost += Math.pow(discountFactor, timeStep) * switchingCostFunction(
					chosenValueAtEachTSMap.get(timeStep), chosenValueAtEachTSMap.get(timeStep + 1));
		}

		return switchingCost;
	}
	
	 /**
   * REVIEWED <br>
   * 
   * Return switching cost in positive values
   * 
   * @return
   */
  public double computeSwitchingCostAllTimeStepContinuous() {
    double switchingCost = 0;

    if (chosenDoubleValueAtEachTSMap.size() == 1) {
      return Double.MAX_VALUE;
    }

    // Compute switching costs from the first time step to the horizon
    for (int timeStep = 0; timeStep < horizon; timeStep++) {
      double valueCurrentTimeStep = chosenDoubleValueAtEachTSMap.get(timeStep);
      double valueNextTimeStep = chosenDoubleValueAtEachTSMap.get(timeStep + 1);
      
      double switchCost = SWITCHING_TYPE == SwitchingType.QUADRATIC ? Math.pow(valueCurrentTimeStep - valueNextTimeStep, 2) : 0;
      
      switchingCost += Math.pow(discountFactor, timeStep) * switchCost;
    }

    return switchingCost;
  }

	/**
	 * Return switching cost in 0 or negative value <br>
	 * If the second argument is null, then return 0
	 * 
	 * @param oldValue
	 * @param newValue
	 * @return
	 */
	public double switchingCostFunction(String oldValue, String newValue) {
		if (oldValue == null || newValue == null) {
			return -Double.MAX_VALUE;
		}
		if (oldValue.isEmpty() || newValue.isEmpty()) {
			return -Double.MAX_VALUE;
		}

		boolean equal = oldValue.equals(newValue);

		double difference = Math.abs(Double.parseDouble(oldValue) - Double.parseDouble(newValue));

		switch (SWITCHING_TYPE) {
		case CONSTANT:
			return equal ? 0 : switchingCost;
		case LINEAR:
			return equal ? 0 : switchingCost * difference;
		case QUADRATIC:
			return equal ? 0 : switchingCost * Math.pow(difference, 2);
		case EXP_2:
			return equal ? 0 : switchingCost * Math.pow(2, difference);
		case EXP_3:
			return equal ? 0 : switchingCost * Math.pow(3, difference);
		}

		return -Double.MAX_VALUE;
	}

	/**
	 * REVIEWED <br>
	 * Has taken into account the sum of discounted utility when FINITE and timeStep
	 * = horizon
	 * 
	 * @param decisionTableList
	 * @param timeStep
	 * @param discountFactor
	 * @return
	 */
	public List<TableString> computeDiscountedDecisionTableList(List<TableString> decisionTableList, int timeStep, double df) {
		List<TableString> tableList = new ArrayList<>();

		for (TableString decisionTable : decisionTableList) {
			tableList.add(computeDiscountedDecisionTable(decisionTable, timeStep, df));
		}
		return tableList;
	}

	/**
	 * REVIEWED <br>
	 * 
	 * @param randomTableList
	 * @param timeStep
	 * @param df
	 * @return
	 */
	public List<TableString> computeDiscountedExpectedRandomTableList(List<TableString> randomTableList, int timeStep, double df) {
		List<TableString> tableList = new ArrayList<>();

		for (TableString randomTable : randomTableList) {
			tableList.add(computeDiscountedExpectedTable(randomTable, timeStep, df));
		}
		return tableList;
	}

	/**
	 * REVIEWED <br>
	 * 
	 * @param inputRandomTable
	 * @param timeStep
	 * @param discountFactor
	 * @return
	 */
	public TableString computeDiscountedExpectedTable(TableString inputRandomTable, int timeStep, double df) {
		TableString randomTable = inputRandomTable;

		if (dynamicType == DynamicType.FINITE_HORIZON && timeStep == horizon) {
			randomTable = computeLongtermExpectedTable(randomTable, timeStep, df);
		}

		List<String> decLabel = randomTable.getDecVarLabel();
		List<String> randLabel = randomTable.getRandVarLabel();
		TableString discountedExpectedTable = new TableString(decLabel, RANDOM_TABLE);

		int randDomainSize = 1;
		for (String randVar : randLabel) {
			randDomainSize *= selfRandomVariableDomainMap.get(randVar).size();
		}

		double expectedUtility = 0;
		// assume all rows contain a given value combination of decision variables are
		// next to each other
		// thus we can traverse in that order to compute the expected utilities from
		// random variable values
		for (int index = 0; index < randomTable.getRowCount(); index++) {
			RowString row = randomTable.getRowList().get(index);

			List<String> decValueList = row.getValueList();
			List<String> randValueList = row.getRandomList();
			double jointProbability = 1;

			for (int idx = 0; idx < randLabel.size(); idx++) {
				String randomVar = randLabel.get(idx);
				String randomValue = randValueList.get(idx);

				jointProbability *= probabilityAtEachTimeStepMap.get(randomVar)[timeStep][selfRandomVariableDomainMap
						.get(randomVar).indexOf(randomValue)];
			}
			expectedUtility += jointProbability * row.getUtility();

			// last turn when traverse to the last value of the random variable(s)
			if (index % randDomainSize == randDomainSize - 1) {
				RowString newRow = new RowString(decValueList, expectedUtility * Math.pow(df, timeStep));
				discountedExpectedTable.addRow(newRow);
				expectedUtility = 0; // reset the expected value for the next decision variable value combination
			}
			// end of traversing row
		}

		return discountedExpectedTable;
	}

	/**
	 * REVIEWED <br>
	 * Used for FINITE_HORIZON at the horizon only
	 * 
	 * @param randomTable
	 * @param timeStep
	 * @return
	 */
	public TableString computeLongtermExpectedTable(TableString randomTable, int timeStep, double df) {
		Set<List<String>> processedDecValues = new HashSet<List<String>>();

		List<String> decVarLabel = randomTable.getDecVarLabel();
		List<String> randVarLabel = randomTable.getRandVarLabel();

		List<List<String>> allTupleValue = getAllTupleValueOfGivenLabeUsingCartesianProduct(randVarLabel, false);

		TableString newlyCreatedTable = new TableString(decVarLabel, randVarLabel, RANDOM_TABLE);

		int noOfEquations = 1;
		for (String randVar : randVarLabel) {
			noOfEquations *= selfRandomVariableDomainMap.get(randVar).size();
		}

		// traverse each row of tableWithRandom
		for (RowString rowToBeTraversed : randomTable.getRowList()) {
			List<String> decValueList = rowToBeTraversed.getValueList();

			// check if decValueList contained in processedDecValues
			if (processedDecValues.contains(decValueList)) {
				continue;
			}
			// search for all values of random Variable
			else {
				processedDecValues.add(decValueList);
				/**
				 * construct unknown equations, by add coefficients
				 *
				 * construct coefficients (1-delta*prob[0,0] - delta*prob[0,1] ... -
				 * delta*prob[0,n] = v0 -delta*prob[1,0] + (1-delta*prob[1,1] ...-
				 * delta*prob[1,n] = v1
				 *
				 * -delta*prob[n,0] - delta*prob[n,1] ... + (1-delta*prob[n,n] = v_n
				 **/
				double coefficients[][] = new double[noOfEquations][noOfEquations + 1];
				// select rowTuple => colTuple
				for (int row = 0; row < noOfEquations; row++) {
					List<String> rowTuple = allTupleValue.get(row);
					// get colTuple
					for (int column = 0; column < noOfEquations; column++) {
						List<String> colTuple = allTupleValue.get(column);
						double transProb = 1;
						for (int randIndex = 0; randIndex < randVarLabel.size(); randIndex++) {
							String randVar = randVarLabel.get(randIndex);
							transProb = transProb * transitionFunctionMap.get(randVar)
									.getProbByValue(rowTuple.get(randIndex), colTuple.get(randIndex));
						}

						if (row == column) {
							coefficients[row][column] = 1 - df * transProb;
						} else {
							coefficients[row][column] = -df * transProb;
						}
					}
					// set utility
					coefficients[row][noOfEquations] = Math.pow(df, timeStep)
							* randomTable.getUtilityFromTableGivenDecAndRand(decValueList, rowTuple);
				}

				// print(Arrays.deepToString(coefficients));
				List<Double> utilityList = gaussian(coefficients, noOfEquations);

				// create new row with a fix dec values, but different rand values
				int i = 0;
				for (List<String> randValueToBeAddedList : allTupleValue) {
					RowString newRow = new RowString(decValueList, randValueToBeAddedList, utilityList.get(i));
					i++;
					newlyCreatedTable.addRow(newRow);
				}
				// end if: decValueList not contained
			}
			// end while: traversing table
		}
		return newlyCreatedTable;
	}

	private List<Double> gaussian(double arr[][], int N) {
		List<Double> longtermUtilityList = new ArrayList<Double>();
		// take each line as pivot, except for the last line
		for (int pivotIndex = 0; pivotIndex < N - 1; pivotIndex++) {
			// go from the line below line pivotIndex, to the last line
			boolean isNotZeroRowFound = false;
			if (arr[pivotIndex][pivotIndex] == 0) {
				int notZeroRow;
				for (notZeroRow = pivotIndex + 1; notZeroRow < N; notZeroRow++) {
					if (arr[notZeroRow][pivotIndex] != 0) {
						isNotZeroRowFound = true;
						break;
					}
				}

				if (isNotZeroRowFound) {
					// swap row pivotIndex and row notZeroRow
					for (int columnToSwapIndex = 0; columnToSwapIndex < N + 1; columnToSwapIndex++) {
						double tempForSwap = arr[pivotIndex][columnToSwapIndex];
						arr[pivotIndex][columnToSwapIndex] = arr[notZeroRow][columnToSwapIndex];
						arr[notZeroRow][columnToSwapIndex] = tempForSwap;
					}
				} else {
					continue;
				}
			}

			for (int rowForGauss = pivotIndex + 1; rowForGauss < N; rowForGauss++) {
				double factor = arr[rowForGauss][pivotIndex] / arr[pivotIndex][pivotIndex];
				for (int columnForGauss = 0; columnForGauss < N + 1; columnForGauss++) {
					arr[rowForGauss][columnForGauss] = arr[rowForGauss][columnForGauss]
							- factor * arr[pivotIndex][columnForGauss];
				}
			}
		}

		for (int columnPivot = N - 1; columnPivot >= 1; columnPivot--) {
			for (int rowAbovePivot = columnPivot - 1; rowAbovePivot >= 0; rowAbovePivot--) {
				double fraction = arr[rowAbovePivot][columnPivot] / arr[columnPivot][columnPivot];
				for (int columnInTheRow = 0; columnInTheRow < N + 1; columnInTheRow++)
					arr[rowAbovePivot][columnInTheRow] = arr[rowAbovePivot][columnInTheRow]
							- fraction * arr[columnPivot][columnInTheRow];
			}
		}

		for (int i = 0; i < N; i++) {
			longtermUtilityList.add(arr[i][N] / arr[i][i]);
		}

		return longtermUtilityList;
	}

	/**
	 * REVIEWED <br>
	 * Compute discounted or sum of discounted
	 * 
	 * @param decisionTable
	 * @param timeStep
	 * @param discountFactor
	 * @return
	 */
	public TableString computeDiscountedDecisionTable(TableString decisionTable, int timeStep, double df) {
		if (decisionTable == null) {
			return null;
		}

		TableString discountedTable = new TableString(decisionTable.getDecVarLabel(), DECISION_TABLE);

		for (RowString decisionTableRow : decisionTable.getRowList()) {
			List<String> valueList = decisionTableRow.getValueList();
			double utility = decisionTableRow.getUtility();

			// Horizon with FINITE
			if (dynamicType == DynamicType.FINITE_HORIZON && timeStep == horizon) {
				discountedTable.addRow(new RowString(valueList, utility * Math.pow(df, timeStep) / (1 - df)));
			} else {
				discountedTable.addRow(new RowString(valueList, utility * Math.pow(df, timeStep)));
			}
		}
		return discountedTable;
	}

	/**
	 * REVIEWED
	 * 
	 * @param randomTableList
	 * @param lastTimeStep
	 * @param df
	 * @return
	 */
	public List<TableString> computeCollapsedRandomTableList(List<TableString> randomTableList, int lastTimeStep, double df) {
		List<TableString> collapedDecistionTableList = new ArrayList<>();
		for (TableString randomTable : randomTableList) {
			List<TableString> similarTableList = new ArrayList<>();

			for (int timeStep = 0; timeStep <= lastTimeStep; timeStep++) {
				similarTableList.add(computeDiscountedExpectedTable(randomTable, timeStep, discountFactor));
			}

			collapedDecistionTableList.add(computeCollapsedTableFromList(similarTableList, RANDOM_TABLE));
		}

		return collapedDecistionTableList;
	}

	/**
	 * NOT REVIEWED BUT TESTED <br>
	 * They have the same entry, only different in utilities
	 * 
	 * @param tableList
	 * @param isRandTable
	 * @return
	 */
	public TableString computeCollapsedTableFromList(List<TableString> tableList, boolean isRandTable) {
		if (tableList.size() == 0) {
			return null;
		}
		TableString joinedTable = new TableString(tableList.get(0).getDecVarLabel(), isRandTable);

		int variableCount = tableList.get(0).getDecVarLabel().size();
		int rowCount = tableList.get(0).getRowCount();
		int tableCount = tableList.size();
		int totalRowCount = (int) Math.pow(rowCount, tableCount);

		for (int count = 0; count < totalRowCount; count++) {
			List<String> valueTuple = new ArrayList<>(variableCount);
			for (int i = 0; i < variableCount; i++) {
				valueTuple.add("");
			}

			double sumUtility = 0;
			int quotient = count;
			// for each table count, decide the index of each column, then add to the tuple
			for (int tableIndex = tableCount - 1; tableIndex >= 0; tableIndex--) {
				int remainder = quotient % rowCount;
				quotient = quotient / rowCount;

				RowString row = tableList.get(tableIndex).getRowList().get(remainder);
				sumUtility += row.getUtility();
				List<String> valueList = row.getValueList();

				for (int idx = 0; idx < valueList.size(); idx++) {
					valueTuple.set(idx, valueList.get(idx) + "," + valueTuple.get(idx));
				}
			}

			for (int idx = 0; idx < valueTuple.size(); idx++) {
				valueTuple.set(idx, valueTuple.get(idx).substring(0, valueTuple.get(idx).length() - 1));
			}

			joinedTable.addRow(new RowString(valueTuple, sumUtility));
		}

		return joinedTable;
	}

	/**
	 * REVIEWED
	 * 
	 * @param decisionTableList
	 * @param lastTimeStep
	 * @param discountFactor
	 * @return
	 */
	public List<TableString> computeCollapsedDecisionTableList(List<TableString> decisionTableList, int lastTimeStep, double df) {
		List<TableString> collapedDecistionTableList = new ArrayList<>();

		// For each table, compute a list of similar tables that are only different in
		// utilities
		for (TableString decTable : decisionTableList) {
			List<TableString> similarTableList = new ArrayList<>();

			for (int timeStep = 0; timeStep <= lastTimeStep; timeStep++) {
				similarTableList.add(computeDiscountedDecisionTable(decTable, timeStep, df));
			}

			collapedDecistionTableList.add(computeCollapsedTableFromList(similarTableList, DECISION_TABLE));
		}

		return collapedDecistionTableList;
	}

	/**
	 * REVIEWED <br>
	 * Compute unary switching cost table given domain and a number of time step
	 * 
	 * @param domain
	 * @param lastTimeStep
	 * @return
	 */
	public TableString computeCollapsedSwitchingCostTable(List<String> domain, int lastTimeStep, double df) {
		List<String> label = new ArrayList<>();
		label.add(agentID);

		TableString collapsedSwitchingCostTable = new TableString(label, DECISION_TABLE);

		List<Set<String>> domainSetList = new ArrayList<Set<String>>();
		for (int timeIndex = 0; timeIndex <= lastTimeStep; timeIndex++) {
			domainSetList.add(new LinkedHashSet<>(domain));
		}

		Set<List<String>> productValues = Sets.cartesianProduct(domainSetList);

		for (List<String> valueList : productValues) {
			double sCost = 0D;

			String valueListString = "";
			for (int i = 0; i < valueList.size() - 1; i++) {
				sCost += Math.pow(df, i) * switchingCostFunction(valueList.get(i), valueList.get(i + 1));
				valueListString += valueList.get(i) + ",";
			}
			valueListString += valueList.get(valueList.size() - 1);

			List<String> finalValueWithCommas = new ArrayList<>();
			finalValueWithCommas.add(valueListString);

			// Add the switching cost from horizon h-1 to h if the value is not null
			// If the value is null, the
			if (lastTimeStep == horizon - 1) {
				sCost += Math.pow(df, horizon - 1)
						* switchingCostFunction(valueList.get(horizon - 1), chosenValueAtEachTSMap.get(horizon));
			}

			collapsedSwitchingCostTable.addRow(new RowString(finalValueWithCommas, -sCost));
		}

		return collapsedSwitchingCostTable;
	}

	public String getAgentID() {
		return agentID;
	}

	public boolean isRoot() {
		return isRoot;
	}

	public boolean isLeaf() {
		return isLeaf;
	}

	public void setLeaf(boolean isLeaf) {
		this.isLeaf = isLeaf;
	}

	public Set<AID> getNeighborAIDSet() {
		return neighborAIDSet;
	}

	public void setNeighborAIDSet(Set<AID> neighborAIDSet) {
		this.neighborAIDSet = neighborAIDSet;
	}

	public Set<String> getNeighborStrSet() {
		return neighborStrSet;
	}

	public void setNeighborStrSet(Set<String> neighborStrSet) {
		this.neighborStrSet = neighborStrSet;
	}

	public boolean isNotVisited() {
		return notVisited;
	}

	public void setNotVisited(boolean notVisited) {
		this.notVisited = notVisited;
	}

	public Set<AID> getChildrenAIDSet() {
		return childrenAIDSet;
	}

	public void setChildrenAIDList(Set<AID> childrenAIDSet) {
		this.childrenAIDSet = childrenAIDSet;
	}

	public AID getParentAID() {
		return parentAID;
	}

	public void setParentAID(AID parentAID) {
		this.parentAID = parentAID;
	}

	public List<String> getParentAndPseudoStrList() {
		return parentAndPseudoStrList;
	}

	public void setParentAndPseudoStrList(List<String> parentAndPseudoStrList) {
		this.parentAndPseudoStrList = parentAndPseudoStrList;
	}

	public Set<AID> getPseudoChildrenAIDSet() {
		return pseudoChildrenAIDSet;
	}

	public void setPseudoChildrenAIDSet(Set<AID> pseudoChildrenAIDSet) {
		this.pseudoChildrenAIDSet = pseudoChildrenAIDSet;
	}

	public Set<AID> getPseudoParentAIDList() {
		return pseudoParentAIDSet;
	}

	public void setPseudoParentAIDList(Set<AID> pseudoParentAIDSet) {
		this.pseudoParentAIDSet = pseudoParentAIDSet;
	}

	public ThreadMXBean getBean() {
		return bean;
	}

	public void setBean(ThreadMXBean bean) {
		this.bean = bean;
	}

	public long getCurrentStartTime() {
		return currentStartTime;
	}

	public void setCurrentStartTime(long currentStartTime) {
		this.currentStartTime = currentStartTime;
	}

	public Map<String, List<String>> getDecisionVariableDomainMap() {
		return decisionVariableDomainMap;
	}

	public void setDecisionVariableDomainMap(HashMap<String, List<String>> decisionVariableDomainMap) {
		this.decisionVariableDomainMap = decisionVariableDomainMap;
	}

	public String getChosenValueAtEachTimeStep(int timeStep) {
		return chosenValueAtEachTSMap.getOrDefault(timeStep, null);
	}

	public void setChosenValueAtEachTimeStep(int timeStep, String chosenValue) {
		this.chosenValueAtEachTSMap.put(timeStep, chosenValue);
	}

	public Map<Integer, String> getChosenValueAtEachTSMap() {
		return this.chosenValueAtEachTSMap;
	}

	public void setValueAtTimeStep(int timeStep, String value) {
		this.chosenValueAtEachTSMap.put(timeStep, value);
	}

	public long getSimulatedTime() {
		return simulatedTime;
	}

	public void setSimulatedTime(long simulatedTime) {
		this.simulatedTime = simulatedTime;
	}

	public void addupSimulatedTime(long time) {
		this.simulatedTime += time;
	}

	public Map<Integer, List<TableString>> getDiscountedExpectedTableEachTSMap() {
		return discountedExpectedTableEachTSMap;
	}

	public TableString getAgentViewTable() {
		return agentViewTable;
	}

	public void setAgentViewTable(TableString agentViewTable) {
		this.agentViewTable = agentViewTable;
	}

	public List<Double> getCurrentGlobalUtilityList() {
		return currentGlobalUtilityList;
	}

	public void setCurrentGlobalUtilityList(List<Double> currentGlobalUtilityList) {
		this.currentGlobalUtilityList = currentGlobalUtilityList;
	}

	public double getSolutionQuality() {
		return solutionQuality;
	}

	public void setSolutionQuality(double solutionQuality) {
		this.solutionQuality = solutionQuality;
	}

	public void increaseSolutionQuality(double quality) {
		this.solutionQuality += quality;
	}

	public static long getDelayMessageTime() {
		return delayMessageTime;
	}

	public static void setDelayMessageTime(long delayMessageTime) {
		AgentPDDCOP.delayMessageTime = delayMessageTime;
	}

	public Map<String, HashMap<Integer, String>> getAgentViewEachTimeStepMap() {
		return agentViewEachTimeStepMap;
	}

	public void setAgentViewEachTimeStepMap(HashMap<String, HashMap<Integer, String>> agentViewEachTimeStepMap) {
		this.agentViewEachTimeStepMap = agentViewEachTimeStepMap;
	}

	public Map<Integer, String> getBestImproveValueMap() {
		return bestImproveValueMap;
	}

	public Map<Integer, Double> getLocalSearchQualityMap() {
		return localSearchQualityMap;
	}

	public double getLocalSearchQualityAt(int iteration) {
		return localSearchQualityMap.getOrDefault(iteration, -Double.MAX_VALUE);
	}

	public void setLocalSearchQuality(int iteration, double quality) {
		this.localSearchQualityMap.put(iteration, quality);
	}

	public Map<Integer, Long> getLocalSearchRuntimeMap() {
		return localSearchRuntimeMap;
	}

	public void setLocalSearchRuntime(int iteration, long runtime) {
		this.localSearchRuntimeMap.put(iteration, runtime);
	}

	public boolean isStop() {
		return stop;
	}

	public void setStop(boolean stop) {
		this.stop = stop;
	}

	public Map<String, String> getValuesToSendInVALUEPhase() {
		return valuesToSendInVALUEPhase;
	}

	public void setValuesToSendInVALUEPhase(HashMap<String, String> valuesToSendInVALUEPhase) {
		this.valuesToSendInVALUEPhase = valuesToSendInVALUEPhase;
	}

	public void addValuesToSendInValuePhase(String agent, String value) {
		this.valuesToSendInVALUEPhase.put(agent, value);
	}
	
	 public void addDoubleValuesToSendInVALUEPhase(String agent, double value) {
	    this.doubleValuesToSendInVALUEPhase.put(agent, value);
	  }

	public Map<Integer, String> getPickedRandomMap() {
		return pickedRandomMap;
	}

	public void setPickedRandomMap(HashMap<Integer, String> pickedRandomMap) {
		this.pickedRandomMap = pickedRandomMap;
	}

	public void addPickedRandomMap(Integer timeStep, String pickedRandomValue) {
		this.pickedRandomMap.put(timeStep, pickedRandomValue);
	}

	public String getPickedRandomAt(Integer timeStep) {
		return this.pickedRandomMap.get(timeStep);
	}

	public long getCurrentUTILstartTime() {
		return currentUTILstartTime;
	}

	public void setCurrentUTILstartTime(long currentUTILstartTime) {
		this.currentUTILstartTime = currentUTILstartTime;
	}

	public String getLastLine() {
		return lastLine;
	}

	public void setLastLine(String lastLine) {
		this.lastLine = lastLine;
	}

	public double[] toArray(List<Double> arrayList) {
		int arrSize = arrayList.size();
		double[] convertedArray = new double[arrSize];
		for (int i = 0; i < arrSize; i++) {
			convertedArray[i] = arrayList.get(i);
		}
		return convertedArray;
	}

	/**
	 * Sample a value from the value at the previous time step and transition
	 * distribution. <br>
	 * If first time step, sample a value for the probability distribution
	 * 
	 * @param currentTimeStep
	 * @return
	 */
	public String simulateOnlineValue(int currentTimeStep) {
		// randomVar is the same as decisionVar string
		String randomVar = agentID;
		double distribution[] = null;

		if (currentTimeStep == 0) {
			distribution = probabilityAtEachTimeStepMap.get(randomVar)[0];	
		}
		// get distribution from transition function, from the previous random values
		else {
			String previousRandValue = pickedRandomMap.get(currentTimeStep - 1);
			distribution = toArray(transitionFunctionMap.get(randomVar).getTransitionOf(previousRandValue));
		}

		double accumualatedProbability = 0;

		for (int i = 0; i < distribution.length; i++) {
			accumualatedProbability += distribution[i];
			if (Double.compare(rdn.nextDouble(), accumualatedProbability) < 0) {
				return selfRandomVariableDomainMap.get(randomVar).get(i);
			}
		}

		return selfRandomVariableDomainMap.get(randomVar).get(0);
	}

	private static double[] multiply(double[] vector, TransitionFunction transFunc) {
		int size = vector.length;
		if (size != transFunc.getSize()) {
			System.err.println("Not a square matrix");
			return null;
		}

		double resultVector[] = new double[size];
		for (int col = 0; col < size; col++) {
			for (int k = 0; k < size; k++) {
				resultVector[col] += vector[k] * transFunc.getProbByIndex(k, col);
			}
		}

		return resultVector;
	}

	public String getOutputFileName() {
		return outputFileName;
	}

	public void setOutputFileName(String outputFileName) {
		this.outputFileName = outputFileName;
	}

	public boolean isAlgorithmIn(PDDcopAlgorithm[] dcopAlgorithmArray) {
		for (PDDcopAlgorithm algorithmInArray : dcopAlgorithmArray) {
			if (pddcop_algorithm == algorithmInArray) {
				return true;
			}
		}

		return false;
	}

	public boolean isDynamic(DynamicType type) {
		return dynamicType == type;
	}

	public DynamicType getDynamicType() {
		return dynamicType;
	}

	public int getHybridTS() {
		return hybridTS;
	}

	public int getHorizon() {
		return horizon;
	}

	public PDDcopAlgorithm getPDDCOP_Algorithm() {
		return pddcop_algorithm;
	}

	public double getSwitchingCost() {
		return switchingCost;
	}

	public int getInstanceID() {
		return instanceID;
	}

	public boolean isFirstInstance() {
		return instanceID == 0;
	}

	public double getHeuristicWeight() {
		return heuristicWeight;
	}

	public Map<String, Double> getAgentHeuristicStringMap() {
		return agentHeuristicStringMap;
	}

	public boolean isRunningPddcopAlgorithm(PDDcopAlgorithm algorithm) {
		return this.pddcop_algorithm == algorithm;
	}

	public String getInputFileName() {
		return inputFileName;
	}

	public List<TableString> getRawDecisionTableList() {
		return rawDecisionTableList;
	}

	public List<TableString> getRawRandomTableList() {
		return rawRandomTableList;
	}

	public double getDiscountFactor() {
		return discountFactor;
	}

	public Map<String, List<String>> getSelfRandomVariableDomainMap() {
		return selfRandomVariableDomainMap;
	}

	public Map<String, double[][]> getProbabilityAtEachTimeStepMap() {
		return probabilityAtEachTimeStepMap;
	}

	public List<TableString> getDpopDecisionTableList() {
		return dpopDecisionTableList;
	}

	public List<TableString> getDpopRandomTableList() {
		return dpopRandomTableList;
	}

	public Map<String, TransitionFunction> getTransitionFunctionMap() {
		return transitionFunctionMap;
	}

	/**
	 * @return the agentCount
	 */
	public int getAgentCount() {
		return agentCount;
	}

	public void updateSolutionQuality(double utility) {
		solutionQuality += utility;
	}

	/**
	 * REVIEWED <br>
	 * Store the solution of DPOP for different algorithms
	 * 
	 * @param value
	 * @param timeStep
	 */
	public void storeDpopSolution(String value, int timeStep) {
		// Store solution at each time step
		if (pddcop_algorithm == PDDcopAlgorithm.C_DCOP) {
			// Set single value at horizon h
			if (dynamicType == DynamicType.INFINITE_HORIZON && timeStep == horizon) {
				chosenValueAtEachTSMap.put(horizon, value);
			}
			// Set a sequence of values
			else {
				String[] values = value.split(",");
				for (int i = 0; i < values.length; i++) {
					chosenValueAtEachTSMap.put(i, values[i]);
				}
			}
		} else {
			chosenValueAtEachTSMap.put(timeStep, value);
		}
	}

	/**
	 * REVIEWED <br>
	 * Compute actual quality for ONLINE algorithms
	 * 
	 * @param timeStep
	 * @return
	 */
	public Map<Integer, Double> computeActualQualityWithoutTime() {
		Map<Integer, Double> solutionQualityMap = new HashMap<>();

		int initTimeStep = pddcop_algorithm == PDDcopAlgorithm.REACT ? -1 : 0;

		for (int ts = initTimeStep; ts <= horizon; ts++) {
			List<TableString> tableList = ts <= 0 ? actualDpopTableAcrossTimeStep.get(0)
					: actualDpopTableAcrossTimeStep.get(ts);

			double sumUtility = 0D;
			for (TableString constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();

				for (String variableInList : decVarList) {
					if (variableInList.equals(agentID)) {
						decValueList.add(chosenValueAtEachTSMap.get(ts));
					} else {
						decValueList.add(agentViewEachTimeStepMap.get(variableInList).get(ts));
					}

				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
			solutionQualityMap.put(ts, sumUtility);
		}

		return solutionQualityMap;
	}

	/**
	 * REVIEWED <br>
	 * From DPOP random table list, return new tables with the corresponding picked
	 * random variables
	 * 
	 * @param timeStep
	 */
	public List<TableString> computeActualDpopTableGivenRandomValues(int timeStep) {
		List<TableString> tableList = new ArrayList<>();

		// traverse to each random table
		for (TableString randTable : getDpopRandomTableList()) {
			List<String> decLabel = randTable.getDecVarLabel();
			// at current time step, create a new table
			// add the tuple with corresponding random values

			TableString newTable = new TableString(decLabel, DECISION_TABLE);

			String simulatedRandomValues = getPickedRandomAt(timeStep);

			for (RowString row : randTable.getRowList()) {
				if (row.getRandomList().get(0).equals(simulatedRandomValues)) {
					newTable.addRow(new RowString(row.getValueList(), row.getUtility()));
				}
			}

			tableList.add(newTable);
		}

		return tableList;
	}
	
	/**
	 * REVIEWED <br>
	 * From DPOP random table list, return new tables with the corresponding picked
	 * random variables
	 * 
	 * @param timeStep
	 */
	public List<TableString> computeRLearningDpopTableGivenRandomValues(int timeStep) {
		List<TableString> tableList = new ArrayList<>();

		// traverse to each random table
		for (TableString randTable : getDpopRandomTableList()) {
			List<String> decLabel = randTable.getDecVarLabel();
			// at current time step, create a new table
			// add the tuple with corresponding random values

			TableString newTable = new TableString(decLabel, DECISION_TABLE);

			String simulatedRandomValues = getPickedRandomAt(timeStep);

			for (RowString row : randTable.getRowList()) {
				if (row.getRandomList().get(0).equals(simulatedRandomValues)) {
					if (timeStep == 0) {
						// Assume unary constraint
						AugmentedState state = AugmentedState.of(simulatedRandomValues, row.getValueList().get(0));
						double utility = RFunction.get(state);
						newTable.addRow(new RowString(row.getValueList(), utility));
//						System.out.println("Agent " + agentID + " for state=" + state + " has R-utility=" + utility);
//						System.out.println("Agent " + agentID + " for state=" + state + " has utility=" + row.getUtility());
					}
					else {
						// Assume unary constraint
						AugmentedState state = AugmentedState.of(simulatedRandomValues, chosenValueAtEachTSMap.get(timeStep - 1), row.getValueList().get(0));
						double utility = RFunction.get(state);
						newTable.addRow(new RowString(row.getValueList(), utility));
//						System.out.println("Agent " + agentID + " for state=" + state + " has R-utility=" + utility);
//						System.out.println("Agent " + agentID + " for state=" + state + " has utility=" + row.getUtility());
					}
				}
			}

			tableList.add(newTable);
		}

		return tableList;
	}

	/**
	 * REVIEWED <br>
	 * Compute switching cost for ONLINE algorithms
	 * 
	 * @return
	 */
	public Map<Integer, Double> computeActualSwitchingCost() {
		Map<Integer, Double> switchingCostMap = new HashMap<>();

		if (pddcop_algorithm == PDDcopAlgorithm.REACT) {
			switchingCostMap.put(0,
					switchingCostFunction(chosenValueAtEachTSMap.get(-1), chosenValueAtEachTSMap.get(0)));
		} else {
			switchingCostMap.put(0, 0D);
		}

		for (int ts = 1; ts <= horizon; ts++) {
			switchingCostMap.put(ts,
					switchingCostFunction(chosenValueAtEachTSMap.get(ts - 1), chosenValueAtEachTSMap.get(ts)));
		}
		return switchingCostMap;
	}

	/**
	 * @return the bestImproveUtilityMap
	 */
	public Map<Integer, Double> getBestImproveUtilityMap() {
		return bestImproveUtilityMap;
	}

	/**
	 * Set currentStartTime at the time the function is called
	 */
	public void startSimulatedTiming() {
		currentStartTime = getBean().getCurrentThreadUserTime();
	}

	/**
	 * Update the simulated runtime += currentTime - currentStartTime
	 */
	public void stopSimulatedTiming() {
		simulatedTime += bean.getCurrentThreadUserTime() - currentStartTime;
	}

	public void print() {
		System.out.println();
	}

	public void print(String s, String agentID) {
		if (agentID.equals(this.agentID)) {
			print(s);
		}
	}

	public void print(String s) {
		System.out.println("Agent " + getLocalName() + " " + s);
	}

	public boolean isRunningPDDCOPLocalSearch() {
		return pddcop_algorithm == PDDcopAlgorithm.LS_RAND || pddcop_algorithm == PDDcopAlgorithm.LS_SDPOP;
	}

	/**
	 * True by default, all agents are assumed to recompute everything
	 * 
	 * @return
	 */
	public boolean isRecomputingDPOP_UTIL() {
		return recomputingDPOP_UTIL;
	}

	/**
	 * Need only set to false
	 * 
	 * @param recomputingDPOP_UTIL
	 */
	public void setRecomputingDPOP_UTILToFalse() {
		this.recomputingDPOP_UTIL = false;
	}

	public TableString getStoredReuseTable() {
		return storedReuseTable;
	}

	public void setStoredReuseTable(TableString storedReuseTable) {
		this.storedReuseTable = storedReuseTable;
	}

	public Set<String> getReuseChildUTIL() {
		return reuseChildUTIL;
	}

	public void setReuseChildUTIL(Set<String> reuseChildUTIL) {
		this.reuseChildUTIL = reuseChildUTIL;
	}

	public Map<Integer, List<TableString>> getActualDpopTableAcrossTimeStep() {
		return actualDpopTableAcrossTimeStep;
	}

	public List<TableString> getActualDpopTableAcrossTimeStep(int timeStep) {
		return actualDpopTableAcrossTimeStep.get(timeStep);
	}

	public void setActualDpopTableAcrossTimeStep(Map<Integer, List<TableString>> actualDpopTableAcrossTimeStep) {
		this.actualDpopTableAcrossTimeStep = actualDpopTableAcrossTimeStep;
	}

	public Map<Integer, List<TableString>> getActualTableAcrossTimeStep() {
		return actualTableAcrossTimeStep;
	}

	public List<TableString> getActualTableAcrossTimeStep(int timeStep) {
		return actualTableAcrossTimeStep.get(timeStep);
	}

	public void setActualTableAcrossTimeStep(Map<Integer, List<TableString>> actualTableAcrossTimeStep) {
		this.actualTableAcrossTimeStep = actualTableAcrossTimeStep;
	}

	public long getOnlineSolvingTime(int timeStep) {
		return onlineSolvingTime.get(timeStep);
	}

	public void setOnlineSolvingTime(int timeStep, long onlineSolvingTimes) {
		onlineSolvingTime.put(timeStep, onlineSolvingTimes);
	}

	public Random getRandomGenerator() {
		return rdn;
	}

	public String getLocalSearchOutputFileName() {
		return localSearchOutputFileName;
	}

	public Map<Integer, Double> getEffectiveQualityMap() {
		return effectiveQualityMap;
	}

	public Map<Integer, Double> getEffectiveSwitchingCostMap() {
		return effectiveSwitchingCostMap;
	}

	public Map<Integer, Long> getEffectiveSolvingTimeMap() {
		return effectiveSolvingTimeMap;
	}

	public long getFinalRuntime() {
		return finalRuntime;
	}

	public void setFinalRuntime(long finalRuntime) {
		this.finalRuntime = finalRuntime;
	}

	public String getCDPOP_value() {
		return CDPOP_value;
	}

	public void setCDPOP_value(String cDPOP_value) {
		CDPOP_value = cDPOP_value;
	}

	/**
	 * @return the randomSeed
	 */
	public long getRandomSeed() {
		return randomSeed;
	}

	/**
	 * @param randomSeed the randomSeed to set
	 */
	public void setRandomSeed(long randomSeed) {
		this.randomSeed = randomSeed;
	}

	public double computeMGMLocalUtility(String regionValue, int timeStep) {
		List<TableString> tableList = new ArrayList<>(mgmTableList);

		double utility = 0;
		for (TableString constraintTable : tableList) {
			List<String> decValueList = new ArrayList<>();
			// get value from agentView
			// add value to decValue -> getUtility
			for (String regionInScope : constraintTable.getDecVarLabel()) {
				if (regionInScope.equals(agentID)) {
					decValueList.add(regionValue);
				} else {
					decValueList.add(agentViewEachTimeStepMap.get(regionInScope).get(timeStep));
				}
			}

			utility += constraintTable.getUtilityGivenDecValueList(decValueList);
		}

		return utility;
	}

	public List<TableString> getMgmTableList() {
		return mgmTableList;
	}

	public void setMgmTableList(List<TableString> mgmTableList) {
		this.mgmTableList = mgmTableList;
	}

	/**
	 * @return the dcop_algorithm
	 */
	public DcopAlgorithm getDcop_algorithm() {
		return dcop_algorithm;
	}

	/**
	 * @param dcop_algorithm the dcop_algorithm to set
	 */
	public void setDcop_algorithm(DcopAlgorithm dcop_algorithm) {
		this.dcop_algorithm = dcop_algorithm;
	}

	public Map<Integer, Double> getMGMQualityMap() {
		return MGMQualityMap;
	}

	public Map<Integer, Long> getMGMRuntimeMap() {
		return MGMRuntimeMap;
	}

	public Map<Integer, Long> getMGMdifferenceRuntimeMap() {
		return MGMdifferenceRuntimeMap;
	}

	public void setMGMdifferenceRuntimeMap(Map<Integer, Long> mGMdifferenceRuntimeMap) {
		MGMdifferenceRuntimeMap = mGMdifferenceRuntimeMap;
	}

	public void setMGMQuality(int localTimeStep, double quality) {
		MGMQualityMap.put(localTimeStep, quality);
	}

	public void setMGMRuntime(int localTimeStep, long runtime) {
		MGMRuntimeMap.put(localTimeStep, runtime);
	}

	/**
	 * @return the total utilities of constraints between self agent and
	 *         parents/pseudo-parents
	 */
	public double getLocalUtilitiesForUTIL(String regionValue, int timeStep) {
		List<TableString> tableList = new ArrayList<>(mgmTableList);

		double utility = 0;
		for (TableString constraintTable : tableList) {
			// Ignore the table if contains child/pseudochild
			List<String> tempLabel = new ArrayList<>(constraintTable.getDecVarLabel());
			tempLabel.remove(agentID);
			tempLabel.removeAll(parentAndPseudoStrList);
			if (!tempLabel.isEmpty()) {
				continue;
			}

			List<String> decValueList = new ArrayList<>();
			// get value from agentView
			// add value to decValue -> getUtility
			for (String regionInScope : constraintTable.getDecVarLabel()) {
				if (regionInScope.equals(agentID)) {
					decValueList.add(regionValue);
				} else {
					decValueList.add(agentViewEachTimeStepMap.get(regionInScope).get(timeStep));
				}
			}

			utility += constraintTable.getUtilityGivenDecValueList(decValueList);
		}

		return utility;
	}

//	public int getOnlineRun() {
//		return onlineRun;
//	}
//
//	public void setOnlineRun(int onlineRun) {
//		this.onlineRun = onlineRun;
//	}

	public void setOnlineOutputFileName(String onlineOutputFileName) {
	}

	/**
	 * @return the onlineOutputFileName
	 */
	public String getOnlineOutputFileName() {
		return onlineOutputFileName;
	}

	public List<TableString> getDpopBoundRandomTableList() {
		return null;
	}

	public double getAverageRewardR() {
		return averageRewardR;
	}

	public void setAverageRewardR(double averageRewardR) {
		this.averageRewardR = averageRewardR;
	}

	public boolean isSolvingForCurrentState() {
		return isSolvingForCurrentState;
	}

	public void setSolvingForCurrentState(boolean isSolvingForCurrentState) {
		this.isSolvingForCurrentState = isSolvingForCurrentState;
	}

	public String getSolutionForCurrentState() {
		return solutionForCurrentState;
	}

	public void setSolutionForCurrentState(String solutionForCurrentState) {
		this.solutionForCurrentState = solutionForCurrentState;
	}

	public String getSolutionForNextState() {
		return solutionForNextState;
	}

	public void setSolutionForNextState(String solutionForNextState) {
		this.solutionForNextState = solutionForNextState;
	}

	public double getAlpha_r() {
		return alpha_r;
	}

	public void setAlpha_r(double alpha_r) {
		this.alpha_r = alpha_r;
	}

	public double getBeta_r() {
		return beta_r;
	}

	public void setBeta_r(double beta_r) {
		this.beta_r = beta_r;
	}
	
	public Map<AugmentedState, Double> getRFunction() {
		return RFunction;
	}

	public void setRFunction(Map<AugmentedState, Double> rFunction) {
		RFunction = rFunction;
	}

	public boolean isApplyingRLearning() {
		return isApplyingRLearning;
	}
	
	public void switchApplyingRLearning() {
		this.isApplyingRLearning = !isApplyingRLearning;
	}

	public void setApplyingRLearning(boolean isApplyingRLearning) {
		this.isApplyingRLearning = isApplyingRLearning;
	}
	
  public Map<AID, Integer> getConstraintInfoMap() {
    return constraintInfoMap;
  }

  public void setConstraintInfoMap(Map<AID, Integer> constraintInfoMap) {
    this.constraintInfoMap = constraintInfoMap;
  }

	public Map<String, Interval> getDecisionVariableIntervalMap() {
		return decisionVariableIntervalMap;
	}

	public void setDecisionVariableIntervalMap(HashMap<String, Interval> decisionVariableIntervalMap) {
		this.decisionVariableIntervalMap = decisionVariableIntervalMap;
	}

	public Map<String, Interval> getSelfRandomVariableIntervalMap() {
		return randomVariableIntervalMap;
	}

	public void setSelfRandomVariableIntervalMap(HashMap<String, Interval> selfRandomVariableIntervalMap) {
		this.randomVariableIntervalMap = selfRandomVariableIntervalMap;
	}
  
  public boolean isContinuous() {
    return dcopType == DcopType.CONTINUOUS;
  }
  
  public boolean isDiscrete() {
    return dcopType == DcopType.DISCRETE;
  }

  public Map<Integer, Double> getMeanAtEveryTimeStep() {
    return meanAtEveryTimeStep;
  }

  public void setMeanAtEveryTimeStep(Map<Integer, Double> meanAtEveryTimeStep) {
    this.meanAtEveryTimeStep = meanAtEveryTimeStep;
  }

  public PiecewiseMultivariateQuadFunction getAgentViewFunction() {
    return agentViewFunction;
  }

  public void setAgentViewFunction(PiecewiseMultivariateQuadFunction agentViewFunction) {
    this.agentViewFunction = agentViewFunction;
  }
  
  public boolean isRunningContinousDpop() {
    return dcop_algorithm == DcopAlgorithm.EC_DPOP || dcop_algorithm == DcopAlgorithm.AC_DPOP ||
        dcop_algorithm == DcopAlgorithm.CAC_DPOP;
  }
  
  public boolean isRuningDPOPFamily() {
    return dcop_algorithm == DcopAlgorithm.EC_DPOP || dcop_algorithm == DcopAlgorithm.AC_DPOP ||
        dcop_algorithm == DcopAlgorithm.CAC_DPOP || dcop_algorithm == DcopAlgorithm.DPOP || dcop_algorithm == DcopAlgorithm.APPROX_DPOP; 
  }

  public Map<Integer, PiecewiseMultivariateQuadFunction> getExpectedFunctionMap() {
    return expectedFunctionMap;
  }
  
  public String getRandomVariable() {
    for (Entry<String, PiecewiseMultivariateQuadFunction> entry : neighborFunctionMap.entrySet()) {
      if (entry.getKey().contains(RANDOM_PREFIX)) {
        return entry.getKey();
      }
    }
    
    return null;
  }
  
  /**
   * Check if neighborFunctionMap has any random variable key
   * @return
   */
  public boolean hasRandomFunction() {
    return getRandomVariable() != null;
  }
  
  public PiecewiseMultivariateQuadFunction getExpectedFunction(int timeStep) {
    return expectedFunctionMap.getOrDefault(timeStep, null);
  }
  
  public boolean isRunningDiscreteAlg() {
    return dcop_algorithm == DcopAlgorithm.DPOP || dcop_algorithm == DcopAlgorithm.MAXSUM || dcop_algorithm == DcopAlgorithm.DISCRETE_DSA;
  }
  
  public boolean isRunningHybridAlg() {
    return dcop_algorithm == DcopAlgorithm.AC_DPOP || dcop_algorithm == DcopAlgorithm.CAC_DPOP 
        || dcop_algorithm == DcopAlgorithm.HYBRID_MAXSUM || dcop_algorithm == DcopAlgorithm.CAC_MAXSUM;
  }

  public Map<Integer, PiecewiseMultivariateQuadFunction> getDpopFunctionEachTimeStepMap() {
    return dpopFunctionEachTimeStepMap;
  }
  
  public void setDpopFunctionEachTimeStepMap(int timeStep, PiecewiseMultivariateQuadFunction function) {
    dpopFunctionEachTimeStepMap.put(timeStep, function);
  }

  public Map<Integer, List<TableString>> getDpopTableEachTimeStepMap() {
    return dpopTableEachTimeStepMap;
  }
  
  public void setDpopTableEachTimeStepMap(int timeStep, List<TableString> tableList) {
    dpopTableEachTimeStepMap.put(timeStep, tableList);
  }
  
  public void clearDpopTableEachTimeStepMap(int timeStep) {
    dpopTableEachTimeStepMap.remove(timeStep);
  }

  public Map<Integer, Set<Double>> getCurrentDiscreteValuesMap() {
    return currentDiscreteValuesMap;
  }
  
  public Set<Double> getCurrentDiscreteValues(int timeStep) {
    return currentDiscreteValuesMap.getOrDefault(timeStep, new HashSet<>());
  }
  
  public void setCurrentDiscreteValues(int timeStep, Set<Double> valueSet) {
    currentDiscreteValuesMap.put(timeStep, valueSet);
  }


  public int getGradientIteration() {
    return gradientIteration;
  }
  
  public Map<String, PiecewiseMultivariateQuadFunction> getNeighborFunctionMap() {
    return neighborFunctionMap;
  }

  /**
   * Mapping: pParent -> function (non-discounted) <br>
   * Also contains: selfAgent -> function, if there is unary constraint
   * This mapping doesn't contain expected and switching cost function <br>
   * @return
   */
  public Map<String, PiecewiseMultivariateQuadFunction> getFunctionWithPParentMap() {
    return functionWithPParentMap;
  }

  public void setFunctionWithPParentMap(String neighbor, PiecewiseMultivariateQuadFunction functionWithPP) {
    functionWithPParentMap.put(neighbor, functionWithPP);
  }
  
  public int getNumberOfPoints() {
    return numberOfPoints;
  }
  
  public boolean isApprox() {
    return isApprox;
  }
  
  public int getNumberOfApproxAgents() {
    return numberOfApproxAgents;
  }
  
  public Interval getSelfInterval() {
    return decisionVariableIntervalMap.get(getLocalName());
  }
  
  public boolean isClustering() {
    return dcop_algorithm == DcopAlgorithm.CAC_DPOP || dcop_algorithm == DcopAlgorithm.CAC_MAXSUM;
  }
  
  public int getLsIteration() {
    return lsIteration;
  }

  public void setLsIteration(int lsIteration) {
    this.lsIteration = lsIteration;
  }

  public void incrementLsIteration() {
    this.lsIteration++;
  }
  
  public void sendObjectMessageWithIteration(AID receiver, Object content, int msgCode, int iteration, long time) {
    ACLMessage message = new ACLMessage(msgCode);
    try {
      message.setContentObject((Serializable) content);
    } catch (IOException e) {
      e.printStackTrace();
    }
    message.addReceiver(receiver);
    message.setLanguage(String.valueOf(time));
    message.setConversationId(String.valueOf(iteration));
    send(message);
  }
  
  public boolean isRunningDPOPFamily() {
    return dcop_algorithm == DcopAlgorithm.EC_DPOP || dcop_algorithm == DcopAlgorithm.AC_DPOP 
        || dcop_algorithm == DcopAlgorithm.CAC_DPOP || dcop_algorithm == DcopAlgorithm.APPROX_DPOP;
  }
  
  /**
   * Do not contain random function and switching cost function
   * @return
   */
  public Map<String, PiecewiseMultivariateQuadFunction> getMSFunctionOwnedByMeMap() {
    return MSFunctionOwnedByMeMap;
  }
  
  public void addNeighborToFunctionOwnedByMe(AID insideAgent) {
    this.functionOwnedByMe.add(insideAgent);
  }
  
  public Set<AID> getNeighborFunctionOwnedByMe() {
    return functionOwnedByMe;
  }

  public Set<AID> getNeighborFunctionOwnedByOther() {
    return functionOwnedByOther;
  }
  
  public void addNeighborToFunctionOwnedByOther(AID outsideAgent) {
    this.functionOwnedByOther.add(outsideAgent);
  }
  
  public Map<AID, MaxSumMessage> getReceived_FUNCTION_TO_VARIABLE() {
    return received_FUNCTION_TO_VARIABLE;
  }

  public void setReceived_FUNCTION_TO_VARIABLE(Map<AID, MaxSumMessage> received_FUNCTION_TO_VARIABLE) {
    this.received_FUNCTION_TO_VARIABLE = received_FUNCTION_TO_VARIABLE;
  }

  public Map<AID, MaxSumMessage> getReceived_VARIABLE_TO_FUNCTION() {
    return received_VARIABLE_TO_FUNCTION;
  }

  public void setReceived_VARIABLE_TO_FUNCTION(Map<AID, MaxSumMessage> received_VARIABLE_TO_FUNCTION) {
    this.received_VARIABLE_TO_FUNCTION = received_VARIABLE_TO_FUNCTION;
  }

  public Map<AID, MaxSumMessage> getStored_FUNCTION_TO_VARIABLE() {
    return stored_FUNCTION_TO_VARIABLE;
  }

  public void setStored_FUNCTION_TO_VARIABLE(Map<AID, MaxSumMessage> stored_FUNCTION_TO_VARIABLE) {
    this.stored_FUNCTION_TO_VARIABLE = stored_FUNCTION_TO_VARIABLE;
  }

  public Map<AID, MaxSumMessage> getStored_VARIABLE_TO_FUNCTION() {
    return stored_VARIABLE_TO_FUNCTION;
  }

  public void setStored_VARIABLE_TO_FUNCTION(Map<AID, MaxSumMessage> stored_VARIABLE_TO_FUNCTION) {
    this.stored_VARIABLE_TO_FUNCTION = stored_VARIABLE_TO_FUNCTION;
  }

  public Map<Integer, Double> getChosenDoubleValueAtEachTSMap() {
    return chosenDoubleValueAtEachTSMap;
  }
  
  public void setChosenDoubleValueAtEachTimeStep(int timeStep, Double doubleValue) {
    chosenDoubleValueAtEachTSMap.put(timeStep, doubleValue);
  }
  
  public double getChosenDoubleValueAtEachTimeStep(int timeStep) {
    return chosenDoubleValueAtEachTSMap.get(timeStep);
  }

  public TableDouble getAgentViewTableDouble() {
    return agentViewTableDouble;
  }

  public void setAgentViewTableDouble(TableDouble agentViewTableDouble) {
    this.agentViewTableDouble = agentViewTableDouble;
  }
  
  /**
   * THIS FUNCTION HAS BEEN REVIEWED WITH FORWARD AND BACKWARD
   * 
   * @param timeStep
   * @param pddcop_alg
   * @param type
   * @return null if the recomputed timeStep with pddcop_alg is < 0 or > h
   */
  public PiecewiseMultivariateQuadFunction computeSwitchingCostDiscountedFunction(int timeStep, PDDcopAlgorithm pddcop_alg, SwitchingType type) {
    // FORWARD: get the value in timeStep - 1
    // BACKWARD: get the value in the timeStep + 1

    int adjustedTimeStep = -1;
    double adjustedDiscounted = 0;
    
    if (pddcop_alg == PDDcopAlgorithm.FORWARD) {
      adjustedTimeStep = timeStep - 1;
      adjustedDiscounted = 1 / discountFactor;
    }
    else if (pddcop_alg == PDDcopAlgorithm.BACKWARD) {
      adjustedTimeStep = timeStep + 1;
      adjustedDiscounted = 1;
    }
    
    if (adjustedTimeStep < 0 || adjustedTimeStep > horizon) {
      return null;
    }
    
    double value = chosenDoubleValueAtEachTSMap.get(adjustedTimeStep);
    
    PiecewiseMultivariateQuadFunction swFunction = new PiecewiseMultivariateQuadFunction();
    Map<String, Interval> intervalMap = new HashMap<>();
    intervalMap.put(getLocalName(), getSelfInterval());
    
    MultivariateQuadFunction func = MultivariateQuadFunction.switchingCostDiscountedFunction(getLocalName(), value, adjustedDiscounted, type);
    swFunction.addToFunctionMapWithInterval(func, intervalMap, NOT_TO_OPTIMIZE_INTERVAL);
    
    return swFunction;
  }

  public Map<String, HashMap<Integer, Double>> getAgentViewDoubleEachTimeStepMap() {
    return agentViewDoubleEachTimeStepMap;
  }

  public void setAgentViewDoubleEachTimeStepMap(Map<String, HashMap<Integer, Double>> agentViewDoubleEachTimeStepMap) {
    this.agentViewDoubleEachTimeStepMap = agentViewDoubleEachTimeStepMap;
  }
  
  public PiecewiseMultivariateQuadFunction computeSumLocalFunction(int timeStep) {
    PiecewiseMultivariateQuadFunction sumFunction = new PiecewiseMultivariateQuadFunction();
    for (PiecewiseMultivariateQuadFunction func : neighborFunctionMap.values()) {
      sumFunction.addPiecewiseFunction(func);
    }
    
    if (hasRandomFunction()) {
      sumFunction.addPiecewiseFunction(expectedFunctionMap.get(timeStep));
    }
    
    PiecewiseMultivariateQuadFunction switchingCostFuncPrev = computeSwitchingCostDiscountedFunction(timeStep, PDDcopAlgorithm.FORWARD, SWITCHING_TYPE);
    PiecewiseMultivariateQuadFunction switchingCostFuncLater = computeSwitchingCostDiscountedFunction(timeStep, PDDcopAlgorithm.BACKWARD, SWITCHING_TYPE);
    
    sumFunction.addPiecewiseFunction(switchingCostFuncPrev);
    sumFunction.addPiecewiseFunction(switchingCostFuncLater);
    
    Map<String, Double> evaluatingDomain = new HashMap<>();
    
    for (String neighbor : neighborStrSet) {
      evaluatingDomain.put(neighbor, agentViewDoubleEachTimeStepMap.get(neighbor).get(timeStep)); 
    }
    
    
    return sumFunction.evaluateToUnaryFunction(evaluatingDomain);
  }
  
  /**
   * REVIEWED
   * 
   * @param lastTimeStep
   */
  public void computeMaximumGainEveryTimeStep() {
    for (int timeStep = 0; timeStep <= horizon; timeStep++) {
      Map<String, Double> selfValue = new HashMap<>();
      selfValue.put(getLocalName(), chosenDoubleValueAtEachTSMap.get(timeStep));
      
      // Compute current utility
      PiecewiseMultivariateQuadFunction sumLocalFunction = computeSumLocalFunction(timeStep);  
      double currentQuality = sumLocalFunction.getTheFirstFunction().evaluateToValueGivenValueMap(selfValue);
      
      Map<String, Interval> selfInterval = new HashMap<>();
      selfInterval.put(getLocalName(), getSelfInterval());
      
      double[] maxArgMax = sumLocalFunction.getTheFirstFunction().getMaxAndArgMax(selfInterval);
      
      localSearchMaximumGain.put(timeStep, maxArgMax[0] - currentQuality);
      localSearchArgmax.put(timeStep, maxArgMax[1]);
    }
  }

  public Map<Integer, Double> getLocalSearchMaximumGain() {
    return localSearchMaximumGain;
  }

  public Map<Integer, Double> getLocalSearchArgmax() {
    return localSearchArgmax;
  }
  
  public String getSelfRanomVariable() {
    return getLocalName().replace("x", "y");
  }

  public Map<String, Double> getDoubleValuesToSendInVALUEPhase() {
    return doubleValuesToSendInVALUEPhase;
  }

  public Map<String, PiecewiseMultivariateQuadFunction> getCurrrentMSFunctionOwnedByMeMap() {
    return currrentMSFunctionOwnedByMeMap;
  }
}
